<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>许嘉华的博客</title>
    <link>https://xujiahua.github.io/</link>
    <description>Recent content on 许嘉华的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 02 Apr 2020 16:58:23 +0800</lastBuildDate>
    
        <atom:link href="https://xujiahua.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Fluentd实战</title>
        <link>https://xujiahua.github.io/posts/use-fluentd/</link>
        <pubDate>Thu, 02 Apr 2020 16:58:23 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/use-fluentd/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/use-fluentd/ -&lt;p&gt;以收集Docker容器日志的例子，介绍下Fluentd的用法。&lt;/p&gt;
&lt;h2 id=&#34;安装-fluentd&#34;&gt;安装 Fluentd&lt;/h2&gt;
&lt;p&gt;Ubuntu 18.04上的安装命令（https://docs.fluentd.org/installation/install-by-deb）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# curl -L https://toolbelt.treasuredata.com/sh/install-ubuntu-bionic-td-agent3.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以Daemon方式启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# systemctl start td-agent.service
root@ubuntu-parallel:~# systemctl status td-agent.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fluentd的安装目录是在/opt/td-agent/下的。为演示方便，我们可以直接使用 &lt;code&gt;/opt/td-agent/embedded/bin/fluentd&lt;/code&gt;这个程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# ps -ef | grep fluentd
td-agent 30596     1  0 17:10 ?        00:00:00 /opt/td-agent/embedded/bin/ruby /opt/td-agent/embedded/bin/fluentd --log /var/log/td-agent/td-agent.log --daemon /var/run/td-agent/td-agent.pid
td-agent 30602 30596  9 17:10 ?        00:00:00 /opt/td-agent/embedded/bin/ruby -Eascii-8bit:ascii-8bit /opt/td-agent/embedded/bin/fluentd --log /var/log/td-agent/td-agent.log --daemon /var/run/td-agent/td-agent.pid --under-supervisor
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他系统的安装参考：https://docs.fluentd.org/installation&lt;/p&gt;
&lt;h3 id=&#34;小试牛刀&#34;&gt;小试牛刀&lt;/h3&gt;
&lt;p&gt;配置文件 test.conf，启动一个HTTP服务，并把接收到的日志，打印到标准输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type http
  port 9880
&amp;lt;/source&amp;gt;

&amp;lt;match *.*&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动fluentd进程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# /opt/td-agent/embedded/bin/fluentd -c test.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过HTTP服务提交日志。可以看到fluentd终端打印出了输入的日志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# curl -X POST -d &#39;json={&amp;quot;event&amp;quot;:&amp;quot;data&amp;quot;}&#39; http://localhost:9880/my.tag
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实战收集linux主机上的docker容器日志&#34;&gt;实战：收集Linux主机上的Docker容器日志&lt;/h2&gt;
&lt;p&gt;Docker官方有fluentd的Logging Driver。不足之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为没有了本地日志文件，docker logs 不管用了。&lt;/li&gt;
&lt;li&gt;需要额外配置，或是在daemon.json里设定，或是docker run时候设定。新增机器或是运行容器，很容易忘记。&lt;/li&gt;
&lt;li&gt;如果远程数据存储down了，会不会丢日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;考虑到这些问题，本实验以收集本地日志的方式使用fluentd。&lt;/p&gt;
&lt;h3 id=&#34;实验前提条件&#34;&gt;实验前提条件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Linux系统&lt;/li&gt;
&lt;li&gt;Docker容器使用默认的Logging Driver，也就是json-file&lt;/li&gt;
&lt;li&gt;容器日志目录（也包含其他配置文件的）&lt;code&gt;/var/lib/docker/containers&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置文件输出到stdout&#34;&gt;配置文件（输出到stdout）&lt;/h3&gt;
&lt;p&gt;定义一个配置文件 docker.container.log.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type tail
  path /var/lib/docker/containers/*/*-json.log
  pos_file /var/log/docker_container.log.pos
  tag docker.*
  refresh_interval 10
  read_from_head true
  &amp;lt;parse&amp;gt;
    @type json
  &amp;lt;/parse&amp;gt;
&amp;lt;/source&amp;gt;

&amp;lt;filter docker.var.lib.docker.containers.*.*.log&amp;gt;
  @type parser
  key_name log
  remove_key_name_field true
  &amp;lt;parse&amp;gt;
    @type json
  &amp;lt;/parse&amp;gt;
&amp;lt;/filter&amp;gt;

&amp;lt;filter docker.var.lib.docker.containers.*.*.log&amp;gt;
  @type record_transformer
  &amp;lt;record&amp;gt;
    container_id ${tag_parts[5]}
    hostname &amp;quot;#{Socket.gethostname}&amp;quot;
  &amp;lt;/record&amp;gt;
&amp;lt;/filter&amp;gt;

&amp;lt;match docker.var.lib.docker.containers.*.*.log&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;简要介绍&#34;&gt;简要介绍&lt;/h4&gt;
&lt;p&gt;一个典型的日志收集过程分三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义数据源，也就是source部分&lt;/li&gt;
&lt;li&gt;每条数据可以增删修改字段，也就是filter部分，filter可以是0个或是多个，按顺序处理。&lt;/li&gt;
&lt;li&gt;数据输出，也就是match部分&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;source&#34;&gt;source&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;@type tail 使用tail插件 &lt;a href=&#34;https://docs.fluentd.org/input/tail&#34;&gt;https://docs.fluentd.org/input/tail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;path 定义路径，正则匹配&lt;/li&gt;
&lt;li&gt;pos_file 存放读文件的offset&lt;/li&gt;
&lt;li&gt;需要定义tag，filter、match使用tag进行匹配。&lt;/li&gt;
&lt;li&gt;tag docker.*，*会被实际的文件名给替代&lt;/li&gt;
&lt;li&gt;refresh_interval 设置多久刷新监听的文件列表，默认60秒&lt;/li&gt;
&lt;li&gt;read_from_head 默认false，也就是，没有pos存在的话，从文件尾读取。设置为true，解决新增文件而文件又没被fluentd及时监听起来的问题。&lt;/li&gt;
&lt;li&gt;parse 使用json解析，因为docker的logging driver用的json-file&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多source插件见：https://docs.fluentd.org/input&lt;/p&gt;
&lt;h4 id=&#34;filter&#34;&gt;filter&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;指定tag pattern&lt;/li&gt;
&lt;li&gt;@type parser 使用parser插件 &lt;a href=&#34;https://docs.fluentd.org/filter/parser&#34;&gt;https://docs.fluentd.org/filter/parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;key_name 需要parse的字段名&lt;/li&gt;
&lt;li&gt;remove_key_name_field 因为我们只需要log字段的json内容，log字段本身不需要保留&lt;/li&gt;
&lt;li&gt;parse 解析为json，因为我们的应用日志是json格式输出的&lt;/li&gt;
&lt;li&gt;@type record_transformer 使用record_transformer插件 &lt;a href=&#34;https://docs.fluentd.org/filter/record_transformer&#34;&gt;https://docs.fluentd.org/filter/record_transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;record 新增字段&lt;/li&gt;
&lt;li&gt;${tag_parts[5]} 预定义的变量，tag_parts是tag字符串被&amp;rdquo;.&amp;ldquo;切分后的数组，第6个代表的是container_id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;#{Socket.gethostname}&amp;quot;&lt;/code&gt; ruby内的变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多filter插件见：https://docs.fluentd.org/filter&lt;/p&gt;
&lt;h4 id=&#34;match&#34;&gt;match&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;指定tag pattern&lt;/li&gt;
&lt;li&gt;@type stdout 使用stdout插件，用于演示 &lt;a href=&#34;https://docs.fluentd.org/output/stdout&#34;&gt;https://docs.fluentd.org/output/stdout&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;启动fluentd&#34;&gt;启动fluentd&lt;/h3&gt;
&lt;p&gt;注意查看日志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# /opt/td-agent/embedded/bin/fluentd -c docker.container.log.conf
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成日志&#34;&gt;生成日志&lt;/h3&gt;
&lt;p&gt;JSON格式输出每一行日志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# docker run -it busybox echo &#39;{&amp;quot;user&amp;quot;:1,&amp;quot;num&amp;quot;:2}&#39;
{&amp;quot;user&amp;quot;:1,&amp;quot;num&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察 &lt;code&gt;/var/lib/docker/containers/*/*-json.log&lt;/code&gt;日志内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;log&amp;quot;:&amp;quot;{\&amp;quot;user\&amp;quot;:1,\&amp;quot;num\&amp;quot;:2}\r\n&amp;quot;,&amp;quot;stream&amp;quot;:&amp;quot;stdout&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2020-04-02T12:25:50.877037148Z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fluentd stdout输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;user&amp;quot;:1,&amp;quot;num&amp;quot;:2,&amp;quot;container_id&amp;quot;:&amp;quot;e4fb94ee2d067450eeaf15837ed1497e2b7eb2f6754ba4eec1792ee37e31f12f&amp;quot;,&amp;quot;hostname&amp;quot;:&amp;quot;ubuntu-parallel&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;输出从stdout改为elasticsearch&#34;&gt;输出从stdout改为elasticsearch&lt;/h3&gt;
&lt;h4 id=&#34;启动es&#34;&gt;启动ES&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://www.elastic.co/guide/en/elastic-stack-get-started/current/get-started-docker.html&#34;&gt;https://www.elastic.co/guide/en/elastic-stack-get-started/current/get-started-docker.html&lt;/a&gt;，使用docker-compose启动es和kibana服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;修改match&#34;&gt;修改match&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;match docker.var.lib.docker.containers.*.*.log&amp;gt;
  @type elasticsearch
  host localhost
  port 9200
  logstash_format true
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：https://docs.fluentd.org/output/elasticsearch&lt;/p&gt;
&lt;h4 id=&#34;启动fluentd-1&#34;&gt;启动fluentd&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-parallel:~# /opt/td-agent/embedded/bin/fluentd -c docker.container.log.es.conf
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;kibana日志分析&#34;&gt;kibana日志分析&lt;/h4&gt;
&lt;p&gt;因为ES的日志已经是JSON格式输出的，所以也不需要额外造数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200403001746670.png&#34; alt=&#34;image-20200403001746670&#34;&gt;&lt;/p&gt;
- https://xujiahua.github.io/posts/use-fluentd/ - </description>
        </item>
    
    
    
        <item>
        <title>使用 Docker Machine</title>
        <link>https://xujiahua.github.io/posts/use-docker-machine/</link>
        <pubDate>Tue, 31 Mar 2020 09:53:05 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/use-docker-machine/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/use-docker-machine/ -&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Docker Machine lets you create Docker hosts on your computer, on cloud providers, and inside your own data center. It creates servers, installs Docker on them, then configures the Docker client to talk to them.&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/docker/machine&#34;&gt;https://github.com/docker/machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/machine/overview/&#34;&gt;https://docs.docker.com/machine/overview/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/machine.png&#34; alt=&#34;Docker Machine&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;vs-vagrant&#34;&gt;vs. Vagrant&lt;/h2&gt;
&lt;h3 id=&#34;与vagrant的交集&#34;&gt;与Vagrant的交集&lt;/h3&gt;
&lt;p&gt;目前使用 Vagrant 搭 Docker 环境的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vagrant init {box_name}，下载一个基础的虚拟机镜像，比如centos，并创建一个Vagrantfile。&lt;/li&gt;
&lt;li&gt;Vagrantfile中设置虚拟机hostname。&lt;/li&gt;
&lt;li&gt;Vagrantfile中设置Private network，使得几个VM可以互相通信。&lt;/li&gt;
&lt;li&gt;VM内安装docker软件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果用上了docker-machine，只要一行命令。在这个场景上，docker-machine 比 Vagrant 方便了很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-machine create -d virtualbox {host_name}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;VM的管理，vagrant命令需要在Vagrantfile所在目录执行。而docker-machine可以在任何目录管理VM。&lt;/p&gt;
&lt;h3 id=&#34;其他特色&#34;&gt;其他特色&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过其他driver，可以安装管理云主机或是私有数据中心，而不仅仅是virtualbox。&lt;/li&gt;
&lt;li&gt;通过eval &amp;ldquo;$(docker-machine env default)&amp;quot;，覆盖环境变量DOCKER_HOST，使得本地docker client访问VM内的docker daemon。&lt;/li&gt;
&lt;li&gt;更多实用命令，参考 &lt;a href=&#34;https://docs.docker.com/machine/get-started/&#34;&gt;https://docs.docker.com/machine/get-started/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/use-docker-machine/ - </description>
        </item>
    
    
    
        <item>
        <title>Consul调研</title>
        <link>https://xujiahua.github.io/posts/use-consul/</link>
        <pubDate>Thu, 26 Mar 2020 09:01:38 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/use-consul/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/use-consul/ -&lt;h2 id=&#34;consul简介&#34;&gt;Consul简介&lt;/h2&gt;
&lt;p&gt;Consul 是 HashiCorp 公司推出的开源分布式服务发现与配置系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现。特别是搭配Consul Connect（Service Mesh），可达到一种无侵入式的服务发现和客户端负载均衡。&lt;/li&gt;
&lt;li&gt;Key/Value 存储 作为配置中心。&lt;/li&gt;
&lt;li&gt;使用 Raft 算法来保证一致性。&lt;/li&gt;
&lt;li&gt;支持多数据中心。&lt;/li&gt;
&lt;li&gt;支持健康检查：服务注册的时候可以提供健康检查项，服务发现会过滤掉不健康的service。&lt;/li&gt;
&lt;li&gt;支持 http 和 dns 协议接口。&lt;/li&gt;
&lt;li&gt;Web 管理界面。&lt;/li&gt;
&lt;li&gt;没有长连接，轮询方式可能不够及时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心概念&#34;&gt;核心概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;consul agent server：维护核心状态并参与leader选举。server节点一般建议3个或是5个，测试用1个即可。写压力大的集群，考虑升级服务器实例的配置和低延迟的存储。（&lt;strong&gt;TIP&lt;/strong&gt; For write-heavy clusters, consider scaling vertically with larger machine instances and lower latency storage. &lt;a href=&#34;https://learn.hashicorp.com/consul/datacenter-deploy/reference-architecture&#34;&gt;https://learn.hashicorp.com/consul/datacenter-deploy/reference-architecture&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;consul agent client：与其他agent联通，并消息中转。每个主机都有一个agent的好处是，只要与本地agent通信，不用设置CONSUL_HTTP_ADDR，代码也不用指定这个地址。方便无脑操作。(In a multi-agent Consul datacenter, each service would register with its local Consul client, and the clients would forward the registration to the Consul servers, which maintain the service catalog. &lt;a href=&#34;https://learn.hashicorp.com/consul/getting-started/services&#34;&gt;https://learn.hashicorp.com/consul/getting-started/services&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;node：一般是一个node一个agent。consul DNS name规则：{node_name}.node.consul&lt;/li&gt;
&lt;li&gt;service：一个service对应多个service实例，注册时使用相同的service_name，并使用不同的service_id区分实例。consul DNS name规则： {service_name}.service.consul&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;入门资料&#34;&gt;入门资料&lt;/h2&gt;
&lt;p&gt;此文就不做复读机了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Getting Started 安装、运行Consul，使用Consul服务发现与配置读写 &lt;a href=&#34;https://learn.hashicorp.com/consul?track=getting-started#getting-started&#34;&gt;https://learn.hashicorp.com/consul?track=getting-started#getting-started&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;consul-服务发现&#34;&gt;Consul 服务发现&lt;/h2&gt;
&lt;h3 id=&#34;微服务与服务发现&#34;&gt;微服务与服务发现&lt;/h3&gt;
&lt;p&gt;从单体应用拆分为微服务，虽然有诸多好处比如不同发布周期的模块拆分平衡了系统稳定性和发布频率，但天下没有免费的午餐。&lt;/p&gt;
&lt;p&gt;以服务发现这个角度看：原来的函数级调用，变成了网络服务级调用。怎么找到网络服务，即其IP+port呢。&lt;/p&gt;
&lt;p&gt;几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置在静态文件。不建议使用，无法应对动态增减服务实例的场景。&lt;/li&gt;
&lt;li&gt;还是配置在静态文件，但配置的是一个负载均衡器比如nginx的地址。其实就是把动态增减服务实例的问题转嫁到了负载均衡器上。调用方也少了做负载均衡的工作。关于nginx处理动态增减服务实例的解决方案，可以参考下节「实践：基于consul的nginx动态upstream」。&lt;/li&gt;
&lt;li&gt;从某中心服务器取，或是轮询或是被通知的方式知道了最新的服务地址。consul 就是这里的中心服务器（集群）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200326114005444.png&#34; alt=&#34;image-20200326114005444&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;服务注册&#34;&gt;服务注册&lt;/h3&gt;
&lt;p&gt;Consul有2种方式注册服务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;consul命令&lt;/li&gt;
&lt;li&gt;HTTP请求&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;健康检查&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;DNS解析或是HTTP取的方式服务发现，只返回通过健康检查的实例。也就是没通过check的服务实例，不会出现，不担心拿到”脏“服务。&lt;/p&gt;
&lt;p&gt;如果服务没有加入健康检查项，默认是健康的。加入健康检查是非常有必要的。还可以设置自动注销，一直不通过检查，就注销该服务实例。&lt;/p&gt;
&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DNS解析&lt;/li&gt;
&lt;li&gt;HTTP请求&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;示例代码&#34;&gt;示例代码&lt;/h3&gt;
&lt;p&gt;参考文章：基于consul构建golang系统分布式服务发现机制 &lt;a href=&#34;https://segmentfault.com/a/1190000008471221&#34;&gt;https://segmentfault.com/a/1190000008471221&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单介绍下，使用Consul HTTP API（有Golang的封装包），进行服务注册和服务发现。&lt;/p&gt;
&lt;h3 id=&#34;一些问题&#34;&gt;一些问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;服务注册、服务发现都在业务代码中。能不能让业务程序无感知？&lt;/li&gt;
&lt;li&gt;对于服务调用方来说，需要自己处理负载均衡。貌似也能通过共享库的方式解决。是否能把这些重复逻辑下沉到基础设施层面？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Service Discovery  &lt;a href=&#34;https://learn.hashicorp.com/consul/getting-started/services&#34;&gt;https://learn.hashicorp.com/consul/getting-started/services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基于consul构建golang系统分布式服务发现机制 &lt;a href=&#34;https://segmentfault.com/a/1190000008471221&#34;&gt;https://segmentfault.com/a/1190000008471221&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实践基于consul的nginx动态upstream&#34;&gt;实践：基于consul的nginx动态upstream&lt;/h2&gt;
&lt;p&gt;以下两种实践参考这个youtube视频：https://www.youtube.com/watch?v=KgTtQnXrnMk。简单提重点。&lt;/p&gt;
&lt;h3 id=&#34;使用-consul-dns接口&#34;&gt;使用 consul DNS接口&lt;/h3&gt;
&lt;p&gt;nginx的resolver关键字指定consul的DNS地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/130267C9-FCE9-4543-9152-C0C1F89DCAB3.png&#34; alt=&#34;130267C9-FCE9-4543-9152-C0C1F89DCAB3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用-consul-template--动态生成upstream文件&#34;&gt;使用 consul-template  动态生成upstream文件&lt;/h3&gt;
&lt;p&gt;创建模板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200326104914256.png&#34; alt=&#34;image-20200326104914256&#34;&gt;&lt;/p&gt;
&lt;p&gt;在模板中定义upstream：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/5A462C56-1A76-4222-8C7A-4041E2775F98.png&#34; alt=&#34;5A462C56-1A76-4222-8C7A-4041E2775F98&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据consul配置信息，刷新nginx配置（然后nginx reload，并自行配置定时刷新周期）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/3C4C8A0F-B629-4215-84FB-2C4D86344FDE.png&#34; alt=&#34;3C4C8A0F-B629-4215-84FB-2C4D86344FDE&#34;&gt;&lt;/p&gt;
&lt;p&gt;业务程序如果也支持动态reload，业务程序的服务发现也能像以上nginx的做法一样。&lt;/p&gt;
&lt;h4 id=&#34;参考-1&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;consul-template &lt;a href=&#34;https://learn.hashicorp.com/consul/developer-configuration/consul-template&#34;&gt;https://learn.hashicorp.com/consul/developer-configuration/consul-template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Manage local application configuration files using templates and data from etcd or consul 与consul-template的思路是一样的 &lt;a href=&#34;https://github.com/kelseyhightower/confd&#34;&gt;https://github.com/kelseyhightower/conf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用-nginx-module&#34;&gt;使用 nginx module&lt;/h3&gt;
&lt;p&gt;An nginx module for setting backends from Consul services.  &lt;a href=&#34;https://github.com/hashicorp/ngx_http_consul_backend_module&#34;&gt;https://github.com/hashicorp/ngx_http_consul_backend_module&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-简单介绍&#34;&gt;Service Mesh 简单介绍&lt;/h2&gt;
&lt;p&gt;Service Mesh是微服务治理的一种模式。&lt;/p&gt;
&lt;p&gt;核心理念就是将业务逻辑无关的代码下沉到基础设施。&lt;/p&gt;
&lt;p&gt;Service Mesh 的代理实例会完成完整的服务间通信的调用流程，如服务发现、负载均衡等基本功能，熔断、限流、重试等容错功能，以及各种高级路由功能，安全方面的认证、授权、鉴权、加密等，最后将请求发送给目标服务。最终表现为Sidecar模式，实现和传统类库类似甚至比传统类库更完备的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/service-mesh-generic-topology_social.png&#34; alt=&#34;“Service Mesh”的图片搜索结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;（来源互联网）&lt;/p&gt;
&lt;p&gt;sidecar是一种不侵入代码的方式，sidecar服务劫持了原服务的流量，sidecar服务与原服务之间使用lo网卡通信。 Connect proxies are typically deployed as &amp;ldquo;sidecars&amp;rdquo; that run on the same node as the single service instance that they handle traffic for. They might be on the same VM or running as a separate container in the same network namespace.   &lt;a href=&#34;https://www.consul.io/docs/connect/registration/sidecar-service.html&#34;&gt;https://www.consul.io/docs/connect/registration/sidecar-service.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh比较成熟的技术有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio：理论上是平台无关的，但实际上，与Kubernetes绑定比较紧密。&lt;/li&gt;
&lt;li&gt;Consul Connect：与Kubernetes没那么强的绑定了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;consul-connect&#34;&gt;Consul Connect&lt;/h2&gt;
&lt;p&gt;Consul Connect是Service Mesh模式的实现。可以理解为Consul服务发现的升级版。&lt;/p&gt;
&lt;p&gt;服务包括sidecar服务的注册只是个注册，实际的进程需要开发者自己创建的。Sidecar service registrations are only a shorthand for registering multiple services. Consul will not start up or manage the actual proxy processes for you. &lt;a href=&#34;https://www.consul.io/docs/connect/registration/sidecar-service.html&#34;&gt;https://www.consul.io/docs/connect/registration/sidecar-service.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;示例-consul-101&#34;&gt;示例 consul-101&lt;/h3&gt;
&lt;p&gt;这个例子。https://github.com/hashicorp/demo-consul-101&lt;/p&gt;
&lt;p&gt;简单说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;consul agent -dev -config-dir=&amp;quot;./demo-config-localhost&amp;quot; -node=laptop&lt;/code&gt; 这里已经完成了service和proxy的注册。这个可以后续脚本化，按需服务注册。&lt;/li&gt;
&lt;li&gt;service本身都不做服务发现和负载均衡。这些事情交给了 sidecar proxy。以dashboard service为例，&lt;code&gt;countingServiceURL = getEnvOrDefault(&amp;quot;COUNTING_SERVICE_URL&amp;quot;, &amp;quot;http://localhost:9001&amp;quot;)&lt;/code&gt;，默认读的是本地的9001端口，也就是proxy的绑定端口。这就是劫持流量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;consul connect proxy -sidecar-for counting-1&lt;/code&gt; 需要手动为service创建proxy。这个可以后续脚本化。&lt;/li&gt;
&lt;li&gt;能看出Consul Connect /Service Mesh的好处了：不再侵入业务代码。重复的事情已下沉到基础设施，sidecar proxy处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基于-consul-connect-的服务发现思路整理&#34;&gt;基于 Consul Connect 的服务发现思路整理&lt;/h3&gt;
&lt;p&gt;非K8S环境。其中调用方为dashboard，被调用方为counting。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络内的所有主机都安装了consul，或是server，或是client。&lt;/li&gt;
&lt;li&gt;基于Consul命令行工具和Consul Connect的能力，让服务注册及服务发现不侵入业务代码。&lt;/li&gt;
&lt;li&gt;counting服务注册流程：准备以下脚本并执行。脚本主要做三件事情。&lt;/li&gt;
&lt;li&gt;1）启动counting服务。counting服务对consul无感知。&lt;strong&gt;这里端口可以是动态的&lt;/strong&gt;，只要让脚本第二步知道即可。&lt;/li&gt;
&lt;li&gt;2）向本地consul注册服务包括sidecar proxy，包括两个服务的健康检查，需要的信息有当前主机IP地址、应用端口等（consul client会转发到consul server的）。&lt;/li&gt;
&lt;li&gt;3）本地创建sidecar proxy服务实例。&lt;/li&gt;
&lt;li&gt;Consul接到counting服务注册后，开始定期健康检查。&lt;/li&gt;
&lt;li&gt;dashboard服务注册流程：与counting服务类似，但是加入了counting proxy upstream部分。比如 &lt;a href=&#34;https://github.com/hashicorp/demo-consul-101/blob/master/demo-config-localhost/dashboard.json#L7&#34;&gt;https://github.com/hashicorp/demo-consul-101/blob/master/demo-config-localhost/dashboard.json#L7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;dashboard服务访问counting服务流程。&lt;/li&gt;
&lt;li&gt;1）dashboard与本地sidecar通信。&lt;/li&gt;
&lt;li&gt;2）dashboard sidecar负载均衡，选择一个counting服务。&lt;/li&gt;
&lt;li&gt;3）dashboard sidecar与counting sidecar通信。&lt;/li&gt;
&lt;li&gt;4）counting sidecar与counting服务通信。&lt;/li&gt;
&lt;li&gt;5）response，同一个通信链路原路返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200326120134716.png&#34; alt=&#34;image-20200326120134716&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;consul-connect-with-envoy&#34;&gt;Consul Connect with Envoy&lt;/h2&gt;
&lt;p&gt;生产环境，sidecar proxy使用Envoy。Consul comes with a L4 proxy for testing purposes, and first-class support for Envoy, which you should use for production deployments and layer 7 traffic management.&lt;/p&gt;
&lt;h3 id=&#34;envoy&#34;&gt;Envoy&lt;/h3&gt;
&lt;p&gt;Envoy编译貌似很复杂。可以把envoy编译产物从镜像里copy出来。 Envoy is only distributed as a Docker image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://learn.hashicorp.com/consul/developer-mesh/connect-services&#34;&gt;https://learn.hashicorp.com/consul/developer-mesh/connect-services&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;demo-todo&#34;&gt;DEMO TODO&lt;/h3&gt;
&lt;h2 id=&#34;配置中心&#34;&gt;配置中心&lt;/h2&gt;
&lt;p&gt;Service Configuratio 配置文件序列化并存入consul kv  &lt;a href=&#34;https://learn.hashicorp.com/consul/getting-started/kv&#34;&gt;https://learn.hashicorp.com/consul/getting-started/kv&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;viper-remote&#34;&gt;viper remote&lt;/h3&gt;
&lt;p&gt;viper支持从consul/etcd取配置信息。 &lt;a href=&#34;https://github.com/spf13/viper#remote-keyvalue-store-support&#34;&gt;https://github.com/spf13/viper#remote-keyvalue-store-support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;consul/etcd没有长连接啊，没有通知，只能定时轮询。Viper内置的库也是HTTP请求。每5秒，去取下最新的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/249E330D-4932-4EC4-BB01-A9E3931D3301.png&#34; alt=&#34;249E330D-4932-4EC4-BB01-A9E3931D3301&#34;&gt;&lt;/p&gt;
- https://xujiahua.github.io/posts/use-consul/ - </description>
        </item>
    
    
    
        <item>
        <title>Docker Network小结</title>
        <link>https://xujiahua.github.io/posts/docker-network/</link>
        <pubDate>Sat, 21 Mar 2020 14:10:40 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/docker-network/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/docker-network/ -&lt;p&gt;Docker网络非常值得学习。对Docker不熟的同学，建议先看一些入门资料。&lt;/p&gt;
&lt;h2 id=&#34;docker-学习资料&#34;&gt;Docker 学习资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Docker — 从入门到实践  &lt;a href=&#34;https://www.yuque.com/grasilife/docker&#34;&gt;https://www.yuque.com/grasilife/docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Kubernetes Lab Handbook &lt;a href=&#34;https://docker-k8s-lab.readthedocs.io/en/latest/index.html&#34;&gt;https://docker-k8s-lab.readthedocs.io/en/latest/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;「Docker进阶与实战」华为Docker实践小组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;单机网络&#34;&gt;单机网络&lt;/h2&gt;
&lt;p&gt;（建议在Linux系统上实验。）&lt;/p&gt;
&lt;p&gt;Docker安装完后，默认有三个（三种）网络。分别是默认的bridge模式，host模式，none模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
51cbe7a9bb19        bridge              bridge              local
7182ef9fa8c4        host                host                local
bd80d0dedaa8        none                null                local
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：https://docs.docker.com/network/&lt;/p&gt;
&lt;h3 id=&#34;none模式---netnone&#34;&gt;none模式 &amp;ndash;net=none&lt;/h3&gt;
&lt;p&gt;无网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker run --net=none --rm -it alpine ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;host模式---nethost&#34;&gt;host模式 &amp;ndash;net=host&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;容器共用宿主机的网络。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。&lt;/li&gt;
&lt;li&gt;容器不会申请独立的IP。&lt;/li&gt;
&lt;li&gt;容器申请的端口占用宿主机的端口资源。&lt;/li&gt;
&lt;li&gt;-p等端口映射命令不起作用：WARNING: Published ports are discarded when using host network mode&lt;/li&gt;
&lt;li&gt;性能上比较好，因为没有地址转换。Host mode networking can be useful to optimize performance, and in situations where a container needs to handle a large range of ports, as it does not require network address translation (NAT), and no “userland-proxy” is created for each port.&lt;/li&gt;
&lt;li&gt;Linux ONLY。The host networking driver only works on Linux hosts, and is not supported on Docker Desktop for Mac, Docker Desktop for Windows, or Docker EE for Windows Server.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/907596-20170517105727775-430532496.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/network/host/&#34;&gt;https://docs.docker.com/network/host/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Networking using the host network &lt;a href=&#34;https://docs.docker.com/network/network-tutorial-host/&#34;&gt;https://docs.docker.com/network/network-tutorial-host/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;实验&#34;&gt;实验&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# docker run --net=host --rm -it alpine ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eno1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP qlen 1000
    link/ether 10:7b:44:b0:b1:37 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.106/24 brd 192.168.0.255 scope global dynamic eno1
       valid_lft 6663sec preferred_lft 6663sec
    inet6 fe80::e0c5:55dc:fba0:549b/64 scope link
       valid_lft forever preferred_lft forever
5: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN
    link/ether 02:42:8c:6e:08:4d brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:8cff:fe6e:84d/64 scope link
       valid_lft forever preferred_lft forever

# ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eno1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 10:7b:44:b0:b1:37 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.106/24 brd 192.168.0.255 scope global dynamic noprefixroute eno1
       valid_lft 6619sec preferred_lft 6619sec
    inet6 fe80::e0c5:55dc:fba0:549b/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
5: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:8c:6e:08:4d brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:8cff:fe6e:84d/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;容器只是隔离除了网络之外的资源。因为使用了宿主机的网络，所以容器进程可以与其他主机进程互相通信。需要注意的是端口冲突的问题，以及安全的问题（共用了宿主机的资源）。&lt;/p&gt;
&lt;h3 id=&#34;bridge模式---netname_it_youself&#34;&gt;bridge模式 &amp;ndash;net={name_it_youself}&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Docker默认的网络模式。不加&amp;ndash;net参数，就默认采用这种网络模式。&lt;/li&gt;
&lt;li&gt;一个独立的虚拟网络。&lt;/li&gt;
&lt;li&gt;宿主机网络对容器网络是无感知的，需要让容器的进程端口映射到宿主机的端口上，同样，映射需要注意端口冲突的问题。&lt;/li&gt;
&lt;li&gt;每个Container都有一个独立的IP。&lt;code&gt;docker network inspect bridge&lt;/code&gt; 可查看。&lt;/li&gt;
&lt;li&gt;同一个虚拟网络下的容器可以互相通信。&lt;/li&gt;
&lt;li&gt;容器可与宿主机通信。&lt;/li&gt;
&lt;li&gt;容器可通过宿主机与其他网络通信。只要宿主机能到，容器就能到。有点像是VMWare中的NAT模式。同样叫bridge，VMWare的bridge模式跟Docker bridge完全不同。&lt;/li&gt;
&lt;li&gt;创建一个新的bridge，就是创建了一个新的子网。&lt;code&gt;docker network create -d bridge my_bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;桥接网络只对一个Docker daemon host上的容器管用，多机就不行了，docker-compose也只能在单机上跑，生产没法用。Bridge networks apply to containers running on the &lt;strong&gt;same Docker daemon host&lt;/strong&gt;. For communication among containers running on different Docker daemon hosts, you can either manage routing at the OS level, or you can use an overlay network.&lt;/li&gt;
&lt;li&gt;建议使用自定义的bridge网络。&lt;/li&gt;
&lt;li&gt;最实用的，自定义网络可以通过容器名称而不是IP与其他容器通信，而默认网络只能通过IP。User-defined bridges provide automatic DNS resolution between containers.&lt;/li&gt;
&lt;li&gt;User-defined bridges provide better isolation.&lt;/li&gt;
&lt;li&gt;Containers can be attached and detached from user-defined networks on the fly.&lt;/li&gt;
&lt;li&gt;网络拓扑如下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/bridge_network.jpg&#34; alt=&#34;“docker bridge network”的图片搜索结果&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;参考-1&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/network/bridge/&#34;&gt;https://docs.docker.com/network/bridge/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Networking with standalone containers &lt;a href=&#34;https://docs.docker.com/network/network-tutorial-standalone/&#34;&gt;https://docs.docker.com/network/network-tutorial-standalone/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;实验-1&#34;&gt;实验&lt;/h4&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;容器模式---netcontainerbase_container&#34;&gt;容器模式 &amp;ndash;net=container:base_container&lt;/h3&gt;
&lt;p&gt;共用其他容器的网络栈，其他资源容器隔离。这个在Service Mesh的场景下非常有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/907596-20170517110100869-2022531474.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;实验-2&#34;&gt;实验&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# docker run -it --name=base_container alpine /bin/ash
/ # ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if9: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
       

# docker run --net=container:base_container --rm -it alpine ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if9: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;跨主机网络&#34;&gt;跨主机网络&lt;/h2&gt;
&lt;p&gt;github上搜索有关Container networking的项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200330115410819.png&#34; alt=&#34;image-20200330115410819&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker-overlay&#34;&gt;Docker Overlay&lt;/h3&gt;
&lt;p&gt;官方提供的方案。之前是需要etcd辅助的。Docker Engine 1.12 integrated the control plane state into Docker Engine so that an external store is no longer required.&lt;/p&gt;
&lt;h3 id=&#34;weave&#34;&gt;Weave&lt;/h3&gt;
&lt;p&gt;Weave Net creates a virtual network that connects Docker containers across multiple hosts and enables their automatic discovery.  参考：https://www.weave.works/docs/net/latest/overview/&lt;/p&gt;
&lt;p&gt;原理是所有容器都连入一个虚拟网络 weave network，所有加入这个网络的容器都有一块weave网卡。要求每台宿主机启动weave。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/weave1.png&#34; alt=&#34;使用Weave 实现Docker 多宿主机互联- 运维之美&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;实验-3&#34;&gt;实验&lt;/h4&gt;
&lt;p&gt;实验参考：https://www.weave.works/docs/net/latest/install/using-weave/&lt;/p&gt;
&lt;p&gt;Docker可以通过插件形式来集成其他网络驱动。看说明weave说明，这种只适合Swarm模式。所以我们实验不采用这种方式。Before using the plugin, please keep in mind the plugin works only in Swarm mode and requires Docker version 1.13 or later. &lt;a href=&#34;https://www.weave.works/docs/net/latest/install/plugin/plugin-v2/&#34;&gt;https://www.weave.works/docs/net/latest/install/plugin/plugin-v2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虚拟机环境搭建，创建两台虚拟机。注意在同一个网络下。参考：https://www.vagrantup.com/docs/networking/private_network.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vagrant init centos/7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（快速）安装Docker。参考：https://www.yuque.com/grasilife/docker/install-centos#ccbf609c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# curl -fsSL get.docker.com -o get-docker.sh
# sh get-docker.sh --mirror Aliyun
# systemctl enable docker
# systemctl start docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装weave。参考：https://www.weave.works/docs/net/latest/install/installing-weave/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# curl -L git.io/weave -o /usr/bin/weave
# chmod a+x /usr/bin/weave
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;weave网络启动，网络的分配将有weave来处理。&lt;code&gt;eval $(weave env)&lt;/code&gt; 覆盖了 DOCKER_HOST 为 unix:///var/run/weave/weave.sock。相当于劫持了docker客户端与docker daemon的通信。参考：https://www.youtube.com/watch?v=kihQCCT1ykE&amp;amp;feature=youtu.be&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host2 vagrant]# weave launch
[root@host2 vagrant]# eval $(weave env)

# join host2
[root@host1 vagrant]# weave launch $host2
[root@host1 vagrant]# eval $(weave env)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连通测试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# start tcp server on container in host2
[root@host2 vagrant]# docker run --name hello busybox nc -lp 8888

# ping from container in host1 to container in host2
[root@host1 vagrant]# docker run --rm -it busybox ping hello
PING hello (10.32.0.1): 56 data bytes
64 bytes from 10.32.0.1: seq=0 ttl=64 time=3.936 ms
64 bytes from 10.32.0.1: seq=1 ttl=64 time=0.616 ms

# tcp test from container in host1 to container in host2
[root@host1 vagrant]# docker run --rm -it busybox sh
/ # echo &amp;quot;hello world!&amp;quot; | nc hello 8888
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看容器网卡，能看到ethwe网卡，与weave有关。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host2 vagrant]# docker run --rm busybox ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
41: eth0@if42: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
43: ethwe@if44: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1376 qdisc noqueue
    link/ether ca:97:90:14:18:5e brd ff:ff:ff:ff:ff:ff
    inet 10.32.0.2/12 brd 10.47.255.255 scope global ethwe
       valid_lft forever preferred_lft forever

[root@host1 vagrant]# docker run --rm busybox ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
29: eth0@if30: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
31: ethwe@if32: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1376 qdisc noqueue
    link/ether da:f2:40:0a:1e:d7 brd ff:ff:ff:ff:ff:ff
    inet 10.44.0.0/12 brd 10.47.255.255 scope global ethwe
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;总结下weave特点&#34;&gt;总结下Weave特点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;通过劫持Docker client与daemon的方式工作。&lt;/li&gt;
&lt;li&gt;创建容器的请求被劫持，weave为容器注入了weave网络。&lt;/li&gt;
&lt;li&gt;不依赖etcd或是consul等kv数据库。&lt;/li&gt;
&lt;li&gt;集群扩容，增加宿主机，需要将宿主机配置为weave节点。&lt;/li&gt;
&lt;li&gt;容器部署，根据资源利用率，部署到哪个宿主机节点。没有容器编排工具，比如Kubernetes，还是挺不方便的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flannel&#34;&gt;Flannel&lt;/h3&gt;
&lt;p&gt;Flannel为每个host分配一个subnet，容器从subnet中分配IP，这些IP可以在host间路由，容器间无需使用nat和端口映射即可实现跨主机通信。每个subnet都是从一个更大的IP池中划分的，flannel会在每个主机上运flanneld的agent，负责从池子中分配subnet。&lt;/p&gt;
&lt;p&gt;Flannel使用etcd存放网络配置、已分配的subnet、host的IP等信息，Flannel数据包在主机间转发是由backend实现的，目前已经支持UDP、VxLAN、host-gw、AWS VPC和GCE路由等多种backend。https://www.cnblogs.com/itzgr/p/10172004.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/docker-flannel.png&#34; alt=&#34;../_images/docker-flannel.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;实验-4&#34;&gt;实验&lt;/h4&gt;
&lt;p&gt;使用docker-machine创建了三台虚拟机。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;etcd&lt;/td&gt;
&lt;td&gt;192.168.99.105&lt;/td&gt;
&lt;td&gt;安装etcd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;192.168.99.108&lt;/td&gt;
&lt;td&gt;安装docker, flannel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node02&lt;/td&gt;
&lt;td&gt;192.168.99.109&lt;/td&gt;
&lt;td&gt;安装docker, flannel&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Multi-Host Networking Overlay with Flannel &lt;a href=&#34;https://docker-k8s-lab.readthedocs.io/en/latest/docker/docker-flannel.html&#34;&gt;https://docker-k8s-lab.readthedocs.io/en/latest/docker/docker-flannel.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Running flannel &lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/running.md&#34;&gt;https://github.com/coreos/flannel/blob/master/Documentation/running.md&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;etcd集群搭建，需要兼容etcd2，因为flannel依赖etcd2。https://github.com/coreos/flannel/issues/1191&lt;/p&gt;
&lt;p&gt;配置一个网段，写入etcd。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@etcd01:~$ etcd -listen-client-urls=&amp;quot;http://0.0.0.0:2379&amp;quot; --advertise-client-urls=&amp;quot;http://192.168.99.105:2379&amp;quot; --enable-v2

docker@etcd01:~$ ETCDCTL_API=2 etcdctl set /coreos.com/network/config &#39;{ &amp;quot;Network&amp;quot;: &amp;quot;10.5.0.0/16&amp;quot;, &amp;quot;Backend&amp;quot;: {&amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot;}}&#39;

docker@etcd01:~$ ETCDCTL_API=2 etcdctl get /coreos.com/network/config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flanneld会读取etcd配置，并为该主机分配子网段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@node01:~# ./flanneld-amd64 -etcd-endpoints=&amp;quot;http://192.168.99.105:2379&amp;quot; -iface=192.168.99.108
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;root@node02:~# ./flanneld-amd64 -etcd-endpoints=&amp;quot;http://192.168.99.105:2379&amp;quot; -iface=192.168.99.109
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，主机上有了新网卡，子网段也会写入etcd。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@etcd01:~$ ETCDCTL_API=2 etcdctl ls /coreos.com/network/subnets
/coreos.com/network/subnets/10.5.94.0-24
/coreos.com/network/subnets/10.5.90.0-24
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置docker daemon参数，boot2docker linux配置如下：参考 &lt;a href=&#34;https://github.com/boot2docker/boot2docker/issues/508&#34;&gt;https://github.com/boot2docker/boot2docker/issues/508&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;node01重新配置docker daemon：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@node01:~# /etc/init.d/docker stop
Stopping dockerd (5350)

root@node01:~# source /run/flannel/subnet.env

root@node01:~# echo EXTRA_ARGS=\&amp;quot;--bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU}\&amp;quot; &amp;gt;&amp;gt; /var/lib/boot2docker/profile
root@node01:~# cat /var/lib/boot2docker/profile

EXTRA_ARGS=&#39;
--label provider=virtualbox

&#39;
CACERT=/var/lib/boot2docker/ca.pem
DOCKER_HOST=&#39;-H tcp://0.0.0.0:2376&#39;
DOCKER_STORAGE=overlay2
DOCKER_TLS=auto
SERVERKEY=/var/lib/boot2docker/server-key.pem
SERVERCERT=/var/lib/boot2docker/server.pem

EXTRA_ARGS=&amp;quot;--bip=10.5.94.1/24 --mtu=1450&amp;quot;

root@node01:~# /etc/init.d/docker start
Starting dockerd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;node02重新配置docker daemon：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@node02:~# /etc/init.d/docker stop
Stopping dockerd (2624)

root@node02:~# source /run/flannel/subnet.env

root@node02:~# echo EXTRA_ARGS=\&amp;quot;--bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU}\&amp;quot; &amp;gt;&amp;gt; /var/lib/boot2docker/profile
root@node02:~# cat /var/lib/boot2docker/profile

EXTRA_ARGS=&#39;
--label provider=virtualbox

&#39;
CACERT=/var/lib/boot2docker/ca.pem
DOCKER_HOST=&#39;-H tcp://0.0.0.0:2376&#39;
DOCKER_STORAGE=overlay2
DOCKER_TLS=auto
SERVERKEY=/var/lib/boot2docker/server-key.pem
SERVERCERT=/var/lib/boot2docker/server.pem


EXTRA_ARGS=&amp;quot;--bip=10.5.90.1/24 --mtu=1450&amp;quot;

root@node02:~# /etc/init.d/docker start
Starting dockerd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连通测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@node01:~# docker run -it busybox
/ # ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: sit0@NONE: &amp;lt;NOARP&amp;gt; mtu 1480 qdisc noop qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
10: eth0@if11: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1450 qdisc noqueue
    link/ether 02:42:0a:05:5e:02 brd ff:ff:ff:ff:ff:ff
    inet 10.5.94.2/24 brd 10.5.94.255 scope global eth0
       valid_lft forever preferred_lft forever
/ # nc -lp 8888

root@node02:~# docker run -it busybox
/ # ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: sit0@NONE: &amp;lt;NOARP&amp;gt; mtu 1480 qdisc noop qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
10: eth0@if11: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1450 qdisc noqueue
    link/ether 02:42:0a:05:5a:02 brd ff:ff:ff:ff:ff:ff
    inet 10.5.90.2/24 brd 10.5.90.255 scope global eth0
       valid_lft forever preferred_lft forever
/ # echo &amp;quot;hello world!&amp;quot; | nc 10.5.94.2 8888
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;总结flannel特点&#34;&gt;总结Flannel特点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;依赖etcd2，在Kubernetes环境里依赖Kubernetes API（封装etcd）。存储网段与路由表？&lt;/li&gt;
&lt;li&gt;不侵入docker容器。这是比weave优雅的地方。&lt;/li&gt;
&lt;li&gt;整体思路，先划分一个大的网段，为每台加入的主机从大的网段里分配小的网段，为docker容器从小网段里分配IP。&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/docker-network/ - </description>
        </item>
    
    
    
        <item>
        <title>Go Web 项目框架</title>
        <link>https://xujiahua.github.io/posts/go-web-project/</link>
        <pubDate>Fri, 20 Mar 2020 15:24:22 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/go-web-project/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/go-web-project/ -&lt;h2 id=&#34;常用开源库&#34;&gt;常用开源库&lt;/h2&gt;
&lt;h3 id=&#34;依赖包管理-go-modules&#34;&gt;依赖包管理 Go Modules&lt;/h3&gt;
&lt;p&gt;Go Modules。Go 从1.11版本开始支持，Go 1.14被认为是生产可用了。个人用过最方便的Go依赖包管理工具了。&lt;/p&gt;
&lt;p&gt;版本管理中维护 &lt;code&gt;go.mod&lt;/code&gt;/&lt;code&gt;go.sum&lt;/code&gt; 两个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320152954581.png&#34; alt=&#34;image-20200320152954581&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Using Go Modules &lt;a href=&#34;https://blog.golang.org/using-go-modules&#34;&gt;https://blog.golang.org/using-go-modules&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;命令行框架-corba&#34;&gt;命令行框架 Corba&lt;/h3&gt;
&lt;p&gt;Corba。第一次看到，是在翻看 Hyperledger Fabric 的时候。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/ad566232-814f-11e5-9cd0-aa101788c117.png&#34; alt=&#34;cobra logo&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子命令，嵌套的子命令。&lt;/li&gt;
&lt;li&gt;增强版本的flags。&lt;/li&gt;
&lt;li&gt;项目模板的生成工具。&lt;/li&gt;
&lt;li&gt;生成工具也自动引入了Viper这个包。Corba与Viper由一个作者开发，两个项目配合使用非常方便。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建议使用Cobra命令行工具生成项目模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ▾ appName/
    ▾ cmd/
        add.go
        your.go
        commands.go
        here.go
      main.go
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;参考-1&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A Commander for modern Go CLI interactions &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cobra Generator &lt;a href=&#34;https://github.com/spf13/cobra/blob/master/cobra/README.md&#34;&gt;https://github.com/spf13/cobra/blob/master/cobra/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置管理-viper&#34;&gt;配置管理 Viper&lt;/h3&gt;
&lt;p&gt;Viper。常常与Corba搭配使用。抄一段官方简介：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/998df88a-8151-11e5-9448-4736db51020d.png&#34; alt=&#34;viper logo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats. It supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setting defaults 设置默认值。示例：&lt;code&gt;viper.SetDefault(&amp;quot;subject&amp;quot;, &amp;quot;World&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;reading from JSON, TOML, YAML, HCL, envfile and Java properties config files 支持各种配置文件格式，TOML比较合我口味。在使用viper之前的配置文件读取方式，一般都是配置文件对应一个Go的model，通过反序列化读入程序。现在看来非常粗糙。&lt;/li&gt;
&lt;li&gt;live watching and re-reading of config files (optional)&lt;/li&gt;
&lt;li&gt;reading from environment variables 读取环境变量。代码和配置严格分离，配置文件算是一种不错的选择，12-Factor更推荐将应用的配置存储于环境变量中，参考：https://12factor.net/zh_cn/config&lt;/li&gt;
&lt;li&gt;reading from remote config systems (etcd or Consul), and watching changes 读配置中心。&lt;/li&gt;
&lt;li&gt;reading from command line flags 示例：&lt;code&gt;viper.BindPFlag(&amp;quot;subject&amp;quot;, helloCmd.Flags().Lookup(&amp;quot;subject&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;reading from buffer&lt;/li&gt;
&lt;li&gt;setting explicit values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Viper can be thought of as a registry for all of your applications configuration needs.&lt;/p&gt;
&lt;h4 id=&#34;关于读环境变量&#34;&gt;关于读环境变量&lt;/h4&gt;
&lt;p&gt;AutomaticEnv is a powerful helper especially when combined with SetEnvPrefix. When called, Viper will check for an environment variable any time a viper.Get request is made. &lt;strong&gt;It will apply the following rules. It will check for a environment variable with a name matching the key uppercased&lt;/strong&gt; and prefixed with the EnvPrefix if set.&lt;/p&gt;
&lt;p&gt;环境变量名是有要求的，默认是大写+下划线组合。如果设置了EnvPrefix，环境变量名需要加上前缀加下划线。&lt;/p&gt;
&lt;p&gt;vip.GetXXX(var) 这里的var倒是大小写随意的，因为viper内部统一小写处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200321181144230.png&#34; alt=&#34;image-20200321181144230&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果环境变量名并不满足组合怎么办呢。使用BindEnv，绑定key与环境变量名之间的关系，而不是使用默认的约定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BindEnv&lt;/code&gt; takes one or two parameters. The first parameter is the key name, the second is the name of the environment variable. The name of the environment variable is case sensitive. If the ENV variable name is not provided, then Viper will automatically assume that the ENV variable matches the following format: prefix + &amp;ldquo;_&amp;rdquo; + the key name in ALL CAPS. &lt;strong&gt;When you explicitly provide the ENV variable name (the second parameter), it does not automatically add the prefix.&lt;/strong&gt; For example if the second parameter is &amp;ldquo;id&amp;rdquo;, Viper will look for the ENV variable &amp;ldquo;ID&amp;rdquo;.&lt;/p&gt;
&lt;h4 id=&#34;参考-2&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Go configuration with fangs &lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;https://github.com/spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;日志-logrus&#34;&gt;日志 logrus&lt;/h3&gt;
&lt;p&gt;Logrus提供的日志功能很丰富。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/687474703a2f2f692e696d6775722e636f6d2f68546556776d4a2e706e67.png&#34; alt=&#34;:walrus:&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSON、TEXT格式输出。JSON很方便解析，配合ES存储日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;参考-3&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Structured, pluggable logging for Go. &lt;a href=&#34;https://github.com/sirupsen/logrus&#34;&gt;https://github.com/sirupsen/logrus&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由库--grollia-mux&#34;&gt;路由库  grollia mux&lt;/h3&gt;
&lt;p&gt;摘抄官方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/68747470733a2f2f636c6f75642d63646e2e7175657374696f6e61626c652e73657276696365732f676f72696c6c612d69636f6e2d36342e706e67.png&#34; alt=&#34;Gorilla Logo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Package &lt;code&gt;gorilla/mux&lt;/code&gt; implements a request router and dispatcher for matching incoming requests to their respective handler.&lt;/p&gt;
&lt;p&gt;The name mux stands for &amp;ldquo;HTTP request multiplexer&amp;rdquo;. Like the standard &lt;code&gt;http.ServeMux&lt;/code&gt;, &lt;code&gt;mux.Router&lt;/code&gt; matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It implements the &lt;code&gt;http.Handler&lt;/code&gt; interface so it is compatible with the standard &lt;code&gt;http.ServeMux&lt;/code&gt;. Go 提供的http.Handler 接口太具有扩展性了。&lt;/li&gt;
&lt;li&gt;Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers. 丰富的路由匹配规则，host、path、header、query string都可以。&lt;/li&gt;
&lt;li&gt;URL hosts, paths and query values can have variables with an optional regular expression.&lt;/li&gt;
&lt;li&gt;Registered URLs can be built, or &amp;ldquo;reversed&amp;rdquo;, which helps maintaining references to resources.&lt;/li&gt;
&lt;li&gt;Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching. 分组功能，RESTful接口按照实体分组，很实用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以搭配同系列的middleware项目使用：https://github.com/gorilla/handlers。&lt;/p&gt;
&lt;h4 id=&#34;参考-4&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A powerful HTTP router and URL matcher for building Go web servers &lt;a href=&#34;https://github.com/gorilla/mux&#34;&gt;https://github.com/gorilla/mux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A collection of useful middleware for Go HTTP services &amp;amp; web applications &lt;a href=&#34;https://github.com/gorilla/handlers&#34;&gt;https://github.com/gorilla/handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Web Server Graceful Shutdown &lt;a href=&#34;https://github.com/gorilla/mux#graceful-shutdown&#34;&gt;https://github.com/gorilla/mux#graceful-shutdown&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;orm-gorm&#34;&gt;ORM gorm&lt;/h3&gt;
&lt;p&gt;文档很丰富。功能很实用。摘抄官方文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full-Featured ORM (almost)&lt;/li&gt;
&lt;li&gt;Associations (Has One, Has Many, Belongs To, Many To Many, Polymorphism)&lt;/li&gt;
&lt;li&gt;Hooks (Before/After Create/Save/Update/Delete/Find)&lt;/li&gt;
&lt;li&gt;Preloading (eager loading)&lt;/li&gt;
&lt;li&gt;Transactions&lt;/li&gt;
&lt;li&gt;Composite Primary Key&lt;/li&gt;
&lt;li&gt;SQL Builder&lt;/li&gt;
&lt;li&gt;Auto Migrations 自动创建表结构。&lt;/li&gt;
&lt;li&gt;Logger&lt;/li&gt;
&lt;li&gt;Extendable, write Plugins based on GORM callbacks&lt;/li&gt;
&lt;li&gt;Every feature comes with tests&lt;/li&gt;
&lt;li&gt;Developer Friendly&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;参考-5&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;GORM Guides &lt;a href=&#34;https://gorm.io/docs/&#34;&gt;https://gorm.io/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;http-client-grequests&#34;&gt;HTTP client grequests&lt;/h3&gt;
&lt;p&gt;号称 Python Requests 的Go clone。用着不错。&lt;/p&gt;
&lt;h4 id=&#34;参考-6&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A Go &amp;ldquo;clone&amp;rdquo; of the great and famous Requests library &lt;a href=&#34;https://github.com/levigross/grequests&#34;&gt;https://github.com/levigross/grequests&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;errors-githubcompkgerrors&#34;&gt;Errors github.com/pkg/errors&lt;/h3&gt;
&lt;p&gt;内置的errors太弱了。返回了error，但是呢，没有返回上下文信息。这个库解决的是这个问题。&lt;/p&gt;
&lt;h4 id=&#34;参考-7&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Simple error handling primitives &lt;a href=&#34;https://github.com/pkg/errors&#34;&gt;https://github.com/pkg/errors&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;依赖注入框架-wire&#34;&gt;依赖注入框架 wire&lt;/h3&gt;
&lt;p&gt;基于代码生成的依赖注入框架。小项目没必要使用。&lt;/p&gt;
&lt;h3 id=&#34;rpc框架-grpc&#34;&gt;RPC框架 gRPC&lt;/h3&gt;
&lt;p&gt;跨进程，跨语言通信。&lt;/p&gt;
&lt;h2 id=&#34;常用工具&#34;&gt;常用工具&lt;/h2&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;p&gt;将常用的命令放在Makefile里管理。比如格式化代码 ，编译，打包，开发环境运行等等，并维护好依赖关系。&lt;/p&gt;
&lt;p&gt;不要写一堆.sh脚本了。&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;p&gt;维护一份Dockerfile，项目交付物通过制作成Docker镜像分发。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Dockerfile
FROM alpine:latest
WORKDIR /app
COPY ./dist .
ENTRYPOINT [&amp;quot;./app&amp;quot;, &amp;quot;serve&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过Docker来构建Go项目（一个两阶段的Dockerfile）。也可以像我这样，在宿主机就构建好，Dockerfile只需要COPY编译产物即可。&lt;/p&gt;
&lt;h3 id=&#34;swagger&#34;&gt;Swagger&lt;/h3&gt;
&lt;p&gt;目前没有方便的生成方法，得手写注释！&lt;/p&gt;
&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;Go web项目结构没有定式，每个人的风格都不一样。参考了这个系列文章，觉得不错，特别是第二篇。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go Web Application Structure - Part 1 &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-pt-1/&#34;&gt;https://aaf.engineering/go-web-application-structure-pt-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go Web Application Structure - Part 2 - Routing/Serving&lt;/strong&gt; &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-2/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Web Application Structure - Part 3 - The Database &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-3/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Web Application Structure - Part 4 - Database Migrations &amp;amp; Business Logic &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-4/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-4/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;code &lt;a href=&#34;https://github.com/theaaf/todos&#34;&gt;https://github.com/theaaf/todos&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;层级调用链：cmd -&amp;gt; api -&amp;gt; app -&amp;gt; db。model/config横切，其它层共享之。&lt;/p&gt;
&lt;h3 id=&#34;model-database-models&#34;&gt;model: database models&lt;/h3&gt;
&lt;p&gt;模型实体，通过分析需求建模，合理的建模便于后期维护。&lt;/p&gt;
&lt;p&gt;横切层。其他每层都会用到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170405357.png&#34; alt=&#34;image-20200320170405357&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;config&#34;&gt;config&lt;/h3&gt;
&lt;p&gt;横切层。&lt;/p&gt;
&lt;p&gt;并没有自己独立的包，而是其他每层都可以根据需要，有一个自己独立的Config结构体。通过一个全局的Viper变量，取出该层关心的配置变量（或是从配置文件，或是从环境变量）。&lt;/p&gt;
&lt;p&gt;比如数据层的config：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170301550.png&#34; alt=&#34;image-20200320170301550&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;db-database-operations&#34;&gt;db: database operations&lt;/h3&gt;
&lt;p&gt;数据持久化层，底层。CRUD操作的封装。通过“构造函数”做依赖注入，方便单元测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170627650.png&#34; alt=&#34;image-20200320170627650&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;app-business-logic&#34;&gt;app: business logic&lt;/h3&gt;
&lt;p&gt;业务逻辑层，中层，核心层。调用数据层，及其他底层服务，比如S3云存储等。&lt;/p&gt;
&lt;h4 id=&#34;三类错误&#34;&gt;三类错误&lt;/h4&gt;
&lt;p&gt;该层方法返回的错误可以分三类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ValidationError 输入不正确，校验不通过，比如手机号长度不对。对应的HTTP状态码：400。&lt;/li&gt;
&lt;li&gt;UserError 认证错误，比如用户登录失败，用户没有权限。对应的HTTP状态码：401, 403。&lt;/li&gt;
&lt;li&gt;ServerError 系统错误，比如数据库连不上，也不需要特别定义ServerError：只要error不是ValidationError，UserError，就是ServerError。对应的HTTP状态码：500。&lt;/li&gt;
&lt;li&gt;没有错误，那么对应的HTTP状态码就是200。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;api-api-controllers&#34;&gt;api: api controllers&lt;/h3&gt;
&lt;p&gt;接口层。尽可能轻量，尽可能没有业务逻辑，只负责转译。通过调用业务逻辑层完成任务。将上述三分类错误映射到合适的状态码。&lt;/p&gt;
&lt;h4 id=&#34;application-state-vs-request-state&#34;&gt;Application State vs. Request State&lt;/h4&gt;
&lt;p&gt;请求入口函数需要为每个请求创建一个context（上下文）。context包含如下，摘抄原文。包含的字段需满足完成request的所需。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320181127465.png&#34; alt=&#34;image-20200320181127465&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;request-context-请求上下文信息&#34;&gt;(Request) Context 请求上下文信息&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Remote IP地址，显示于access log。使用logrus.WithField()。&lt;/li&gt;
&lt;li&gt;Request ID，显示于access log。使用logrus.WithField()。&lt;/li&gt;
&lt;li&gt;User，用于后续鉴权。如果有认证头信息（Auth Token），从数据库取出用户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cmd-command-line-methods&#34;&gt;cmd: command line methods&lt;/h3&gt;
&lt;p&gt;使用Cobra生成子命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app serve &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动web server，并加入web server优雅退出的功能。&lt;/p&gt;
- https://xujiahua.github.io/posts/go-web-project/ - </description>
        </item>
    
    
    
        <item>
        <title>Go库对URL Path中%2F的处理</title>
        <link>https://xujiahua.github.io/posts/slash-in-url-path/</link>
        <pubDate>Thu, 12 Mar 2020 15:17:36 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/slash-in-url-path/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/slash-in-url-path/ -&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;有同事反馈Go项目的接口404了。看了下nginx日志，只有部分请求404了，404请求的显著特征是URL里有&lt;code&gt;%2F&lt;/code&gt;，也就是&lt;code&gt;/&lt;/code&gt;的转义。&lt;/li&gt;
&lt;li&gt;接口定义是这样的：&lt;code&gt;/api/xxx/{mid}/{uid}&lt;/code&gt;。mid、uid是URL path的一部分。从现象来看，程序没处理好转义字符，因为多了一个path部分，路由不匹配了，404。&lt;/li&gt;
&lt;li&gt;nginx的URL记录是&lt;code&gt;%2F&lt;/code&gt;，其实调用方传的是微信ID，比如&lt;code&gt;IEd5W/jqsdF9qpuagQscEg==&lt;/code&gt;。调用方在发请求之前对ID已经做好了转义。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;go内置库不区分2f和&#34;&gt;Go内置库：不区分&lt;code&gt;%2F&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;An application cannot distinguish between &amp;ldquo;/&amp;rdquo; used as a path segment delimiter and &amp;ldquo;/&amp;rdquo; encoded in a path segment.&lt;/p&gt;
&lt;p&gt;这个问题由来已久了，看着官方也不打算解决了，见这个issue：https://github.com/golang/go/issues/3659&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;If your app needs to assign special meaning, the
server can reprocess req.RequestURI as it sees fit, and the client can
issue requests using &amp;amp;url.URL{Opaque: rawURI}.
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;reprocess req.RequestURI 就是让你别用内置路由库了。&lt;/li&gt;
&lt;li&gt;issue requests using &amp;amp;url.URL{Opaque: rawURI}. 试了，问题没解决。客户端不管怎么做，最终都是以HTTP协议输出的。&lt;code&gt;GET http://www.google.com/index.html HTTP/1.1&lt;/code&gt; 服务端代码最终解析的还是中间的那段URL文本。照理就不通啊。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;源码角度&#34;&gt;源码角度&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;url.URL&lt;/code&gt;的定义，明确指出Path字段存储的是decode之后的数据，所以&lt;code&gt;%2F&lt;/code&gt;在这里已经被转义成了&lt;code&gt;/&lt;/code&gt;，跟之前的Path意义完全不同了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312154454662.png&#34; alt=&#34;image-20200312154454662&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http.ServeMux&lt;/code&gt;也是依赖Path进行路由的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312155554309.png&#34; alt=&#34;image-20200312155554309&#34;&gt;&lt;/p&gt;
&lt;p&gt;而http.Request中的URL字段是怎么从HTTP协议中解析出来的呢，从http.ListenAndServe顺藤摸瓜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312163138455.png&#34; alt=&#34;image-20200312163138455&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后还是在parse rawurl字符串，红框里会做path的转义操作，坑之所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312164058458.png&#34; alt=&#34;image-20200312164058458&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用Go内置的http路由，代码都写死了：URL解析代码中，Path一定是decode后的数据；路由代码中使用Path来路由。问题得不到解决。&lt;/p&gt;
&lt;h2 id=&#34;gorillamux-useencodedpath&#34;&gt;gorilla/mux: UseEncodedPath()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.gorillatoolkit.org/pkg/mux&#34;&gt;http://www.gorillatoolkit.org/pkg/mux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312170420310.png&#34; alt=&#34;image-20200312170420310&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用这个方法就可以基于encoded Path进行路由了。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/http/httptest&amp;quot;

	&amp;quot;github.com/gorilla/mux&amp;quot;
)

func main() {
	router := mux.NewRouter().UseEncodedPath() # 创建router的时候设置
	router.NewRoute().Name(&amp;quot;test&amp;quot;).Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/test/{name}&amp;quot;).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, mux.Vars(r))
	})
	server := httptest.NewServer(router)
	defer server.Close()

	res, err := http.Get(server.URL + &amp;quot;/test/bob%2Fvanderlen&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	greeting, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&amp;quot;%s&amp;quot;, greeting)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;源码角度-1&#34;&gt;源码角度&lt;/h3&gt;
&lt;p&gt;通过flag来控制是否用encode过的还是decode过的Path。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312171317394.png&#34; alt=&#34;image-20200312171317394&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;还不完美&#34;&gt;还不完美&lt;/h2&gt;
&lt;p&gt;期望取到的数据是&lt;code&gt; IEd5W/jqsdF9qpuagQscEg==&lt;/code&gt;。然而，Path变量的取值仍然是根据标志位来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312173633090.png&#34; alt=&#34;image-20200312173633090&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，即使让请求找到了路由，还是取不到真正的值。还得对URL Path进行手动decode才能用其中的值。让人崩溃，好多地方要改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312174326015.png&#34; alt=&#34;image-20200312174326015&#34;&gt;&lt;/p&gt;
&lt;p&gt;不完美，但至少不需要让调用者改代码了。以后接口设计还是把请求参数放Body里，稳一点。&lt;/p&gt;
- https://xujiahua.github.io/posts/slash-in-url-path/ - </description>
        </item>
    
    
    
        <item>
        <title>专利申请流程小结</title>
        <link>https://xujiahua.github.io/posts/patent/</link>
        <pubDate>Wed, 11 Mar 2020 11:25:09 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/patent/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/patent/ -&lt;p&gt;去年憋的一篇专利，到申请公布阶段了，算是去年研究区块链的副成果。https://patents.google.com/patent/CN110807211。整理下专利申请流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/01C8BAF0-B9C7-4F08-9575-38AF85AC4F14.png&#34; alt=&#34;01C8BAF0-B9C7-4F08-9575-38AF85AC4F14&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;专利申请流程&#34;&gt;专利申请流程&lt;/h2&gt;
&lt;p&gt;主要流程如下图，来自网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7CA0DB1A-692F-481B-BFA3-987F503E1E39.png&#34; alt=&#34;7CA0DB1A-692F-481B-BFA3-987F503E1E39&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;技术成果生成&#34;&gt;技术成果生成&lt;/h3&gt;
&lt;p&gt;有可以申请专利的点，这个因人而异。基于点子，写个草稿。&lt;/p&gt;
&lt;h3 id=&#34;申请专利&#34;&gt;申请专利&lt;/h3&gt;
&lt;p&gt;找一个专利代理，让他们提供专利稿的修改意见。反复迭代直到专利代理觉得没问题了。&lt;/p&gt;
&lt;p&gt;之后专利代理会出具一份「专利申请受理通知书」，你再交点钱，可能还会有税费减免。&lt;/p&gt;
&lt;p&gt;我遇到了专利代理看不大懂专利的情况，僵持了一段时间，后面换了一家顺畅好多。&lt;/p&gt;
&lt;h3 id=&#34;专利申请公布&#34;&gt;专利申请公布&lt;/h3&gt;
&lt;p&gt;这个时间点叫做：申请公布日。&lt;/p&gt;
&lt;p&gt;说明初审过了。实用新型和外观发明的话，直接就授权了，而发明还需要实质审查。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;初步审查合格后，实用新型和外观就直接授权了，而发明还要经过实质审查，检索国内外的资料，确认没有相同的才会授权，所以发明的含金量会高很多，因此发明专利审查的时间也会是比较长的，一般从申请到拿证书都需要2-3年，而实用、外观这两项专利一年能拿到。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;专利授权公告&#34;&gt;专利授权公告&lt;/h3&gt;
&lt;p&gt;这个时间点叫做：授权公告日。&lt;/p&gt;
&lt;p&gt;说明正式审查完了。这时候才算是真正拥有专利。&lt;/p&gt;
- https://xujiahua.github.io/posts/patent/ - </description>
        </item>
    
    
    
        <item>
        <title>Github pages重新开始：使用Hugo、Typora</title>
        <link>https://xujiahua.github.io/posts/github-pages-restart/</link>
        <pubDate>Tue, 10 Mar 2020 11:24:49 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/github-pages-restart/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/github-pages-restart/ -&lt;h2 id=&#34;重新开始github-pages&#34;&gt;重新开始GitHub pages&lt;/h2&gt;
&lt;p&gt;曾使用&lt;code&gt;GitHub pages&lt;/code&gt; + &lt;code&gt; jekyll&lt;/code&gt; 写过一段时间博客，没啥营养。&lt;/p&gt;
&lt;p&gt;打算重新开始：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把我记录在Evernote和Typora中的资料迁移到&lt;code&gt;GitHub pages&lt;/code&gt;上。&lt;/li&gt;
&lt;li&gt;另外做一些Web形式的小工具，挂载在一个子目录里，方便平时使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hugo--typora&#34;&gt;Hugo + Typora&lt;/h2&gt;
&lt;p&gt;打算如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Markdown文件还是使用Typora写。用过MWeb、Typora，Typora使用感受更好些（这么好用还不要钱）。&lt;/li&gt;
&lt;li&gt;Hugo作为静态网站生成，创建一个博客模板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hugo-quickstart&#34;&gt;Hugo quickstart&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 安装hugo（其实是Go编译的二进制文件）
brew install hugo

# 创建site
hugo new site quickstart

# 通过git submodule的方式下载主题
git init
git submodule -b master add https://github.com/dillonzq/LoveIt themes/LoveIt

# 更新config.toml，配置主题参数，见loveit配置

# 创建博客，创建的posts在content目录下。文件格式为：content/&amp;lt;CATEGORY&amp;gt;/&amp;lt;FILE&amp;gt;.&amp;lt;FORMAT&amp;gt;
# hugo new 会采用 archetypes/default.md作为模板，把一些共性配置放在这个模板里吧。
hugo new posts/my-first-post.md

# 本地看blog效果，-D表示草稿状态的博客也显示
hugo server -D

# 生成静态网站到./public/，也可以指定目录
hugo -D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挑选了一个比较实用的主题 &lt;a href=&#34;https://hugoloveit.com/&#34;&gt;https://hugoloveit.com/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较基本的posts, tags, categories&lt;/li&gt;
&lt;li&gt;文章页面右边可显示文章的目录表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hugoloveit.com/theme-documentation-basics/&#34;&gt;https://hugoloveit.com/theme-documentation-basics/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;图片文件夹的配置&#34;&gt;图片文件夹的配置&lt;/h3&gt;
&lt;p&gt;Typora的贴图功能很方便：配置好图片文件夹，从剪贴板粘贴图像会自动将图片保存到图片文件夹，并自动命名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt;管理静态资源的方式跟Typora默认是不适配的，需要做些调整。&lt;/p&gt;
&lt;h5 id=&#34;长话短说&#34;&gt;长话短说&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;项目中，创建&lt;code&gt;static/images&lt;/code&gt;文件夹，并且软链接到项目根目录下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p static/images &amp;amp;&amp;amp; ln -s `pwd`/static/images images
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Typora打开content目录，并做配置如下。之后，像平常那样用Typora写文字吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200310184153667.png&#34; alt=&#34;image-20200310184153667&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;在根目录建images软链接的理由&#34;&gt;在根目录建&lt;code&gt;images&lt;/code&gt;软链接的理由&lt;/h5&gt;
&lt;p&gt;一些信息和思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;的静态资源放在static目录下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;生成静态文件，static目录会将其下的文件、文件夹平移到目标网站目录的根目录，比如&lt;code&gt;static/images/1.png&lt;/code&gt;，平移后为&lt;code&gt;images/1.png&lt;/code&gt;。html里使用&lt;code&gt;/images/*&lt;/code&gt;的方式引用。（可查看public文件夹的目录结构）&lt;/li&gt;
&lt;li&gt;hugo static目录下的资源目录不能是软链接，WTF。Unsupported symlink found &lt;a href=&#34;https://github.com/gohugoio/hugo/issues/6225&#34;&gt;https://github.com/gohugoio/hugo/issues/6225&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;万幸Typora可以用软链接。&lt;/li&gt;
&lt;li&gt;一篇post，在浏览器和文件系统上的目录结构是不同的。以最末层的文件夹为&lt;code&gt;./&lt;/code&gt;。浏览器下目录结构如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;/ =&amp;gt; ../.. 举例来说，以图片文件夹名称为`image`为例，`../../images/*` = `/images/*`
	/posts/ =&amp;gt; ../
		/posts/post_name/ =&amp;gt; ./
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;文件系统下的目录结构：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;hugo-blogger =&amp;gt; ../../
	content =&amp;gt; ../
		posts =&amp;gt; ./
			post_name
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;所以为了能让文件系统和浏览器上都显示图像，&lt;code&gt;images&lt;/code&gt;软链接放在项目根目录下比较合适。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;github-pages&#34;&gt;GitHub pages&lt;/h3&gt;
&lt;p&gt;静态文件输出到xujiahua.github.io上去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule add -b master https://github.com/XUJiahua/XUJiahua.github.io.git public
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复用这里的deploy脚本。https://gohugo.io/hosting-and-deployment/hosting-on-github/#put-it-into-a-script&lt;/p&gt;
&lt;h4 id=&#34;图片资源404的问题&#34;&gt;图片资源404的问题&lt;/h4&gt;
&lt;p&gt;_images文件夹下的资源404了。太奇怪了，路径OK，也没大小问题。过了很久还是不见效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312190900210.png&#34; alt=&#34;image-20200312190900210&#34;&gt;&lt;/p&gt;
&lt;p&gt;尝试在images文件夹下放了个1.txt，理论上链接应该是 &lt;a href=&#34;https://xujiahua.github.io/images/1.txt&#34;&gt;https://xujiahua.github.io/images/1.txt&lt;/a&gt;，一开始也是404。过了半小时OK了。&lt;/p&gt;
&lt;p&gt;结论是，_images文件夹取名可能有问题。那就改用images。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34;&gt;https://gohugo.io/hosting-and-deployment/hosting-on-github/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/github-pages-restart/ - </description>
        </item>
    
    
    
        <item>
        <title>Hyper-V使用体验</title>
        <link>https://xujiahua.github.io/posts/use-hyper-v/</link>
        <pubDate>Tue, 03 Mar 2020 22:13:23 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/use-hyper-v/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/use-hyper-v/ -&lt;h2 id=&#34;hyper-v-使用体验&#34;&gt;Hyper-V 使用体验&lt;/h2&gt;
&lt;p&gt;Hyper-V是 Windows10 内置的虚拟机软件，没想到我会用到它。&lt;/p&gt;
&lt;h3 id=&#34;为什么要用hyper-v&#34;&gt;为什么要用Hyper-V&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要使用虚拟机来模拟Kubernetes环境。&lt;/li&gt;
&lt;li&gt;Windows Docker依赖Hyper-V。貌似WSL2也是基于Hyper-V。应该是不会卸载Hyper-V了。&lt;/li&gt;
&lt;li&gt;Hyper-V与其他虚拟机软件（VirtualBox, VMWare）冲突，用不了其他的，只能用Hyper-V。&lt;/li&gt;
&lt;li&gt;Hyper-V与VirtualBox兼容的方案有没有。可能有，不想过于折腾了，那就不得不用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hyper-v好不好用&#34;&gt;Hyper-V好不好用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用体验太差了，从Mac、从其他虚拟机使用过来，默认配置各种踩坑。&lt;/li&gt;
&lt;li&gt;安装VM碰到DHCP超时的问题，反复试验无果，重启Windows后VM的DHCP不超时了。总结下，Windows上，如果怎么搞都搞不定，重启下可能就好了。WTF！&lt;/li&gt;
&lt;li&gt;自带的NAT网络有点残疾，VM配置静态IP，网络就不通了。不像VirtualBox是开箱即用的。&lt;/li&gt;
&lt;li&gt;最后借助网络上的零碎信息自定义了下NAT网络，各种神奇配置。&lt;/li&gt;
&lt;li&gt;Windows还是很屎，除了打游戏，开发体验跟我之前的体验一样糟。最后搞定花了我一天时间。要是用VMware/VirtualBox，可能在2个小时内就能搞定。总结，不好用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hyper-v-创建和克隆vm&#34;&gt;Hyper-V 创建和克隆VM&lt;/h2&gt;
&lt;h3 id=&#34;创建vm&#34;&gt;创建VM&lt;/h3&gt;
&lt;p&gt;从&lt;code&gt;*.iso&lt;/code&gt;文件创建VM。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/465F25A3-07A1-4DB7-90CE-FD02376D4C92.png&#34; alt=&#34;465F25A3-07A1-4DB7-90CE-FD02376D4C92&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意，Linux VM，不启用Windows Secure Boot。&lt;/li&gt;
&lt;li&gt;更多选项里，设置VM的名称和交换机。&lt;/li&gt;
&lt;li&gt;体验不好的地方：左上方的「选择操作系统」区域有长时间的加载过程，即使使用本地镜像文件也得等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;克隆vm&#34;&gt;克隆VM&lt;/h3&gt;
&lt;p&gt;从硬盘文件创建VM。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/03603F71-9B97-4ABC-8D1F-91F6CBB6602E.png&#34; alt=&#34;03603F71-9B97-4ABC-8D1F-91F6CBB6602E&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/3C85F0B5-0763-468F-9ABC-2FC35AF20235.png&#34; alt=&#34;3C85F0B5-0763-468F-9ABC-2FC35AF20235&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;克隆是为了减少重复配置一些基础环境的工作量。&lt;/li&gt;
&lt;li&gt;不像VirtualBox那样有直观的克隆按钮。摸索出的克隆功能是这样的：就是从VM硬盘创建VM。&lt;/li&gt;
&lt;li&gt;建议先关机母体VM后，再基于母体VM的硬盘文件克隆。防止母体VM开机状态下一些更新并没有持久化到硬盘文件中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hyper-v-nat网络搭建总结&#34;&gt;Hyper-V NAT网络搭建总结&lt;/h2&gt;
&lt;p&gt;如果使用VMWare/VirtualBox的话，NAT网络是完全自动搭建的。&lt;/p&gt;
&lt;p&gt;VMWare中有三种网络模式，Bridging、NAT、Host-only分别对应Hyper-V下的三种交换机，外部、内部、专用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bridging：VM使用物理网络。GUEST VM与HOST相当于通过交换机连上一个网络（细节不确定）。&lt;/li&gt;
&lt;li&gt;NAT：VM使用虚拟网络，HOST同时连入物理网络和虚拟网络。VM出口流量都会通过HOST，使用HOST IP。&lt;/li&gt;
&lt;li&gt;Host-only：在NAT基础上，VM连不上外网，除非有路由设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;默认的nat网络&#34;&gt;默认的NAT网络&lt;/h3&gt;
&lt;p&gt;默认交换机支持NAT，但是瑕疵不少，无法满足工作需要。&lt;/p&gt;
&lt;p&gt;Hyper-V Default Switch + VM DHCP 的组合默认有了NAT功能，满足以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机之间可以互相访问&lt;/li&gt;
&lt;li&gt;虚拟机与物理机之间可以互相访问&lt;/li&gt;
&lt;li&gt;虚拟机可以访问互联网&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次重启，Default Switch的IP都会变，Windows10 物理机上的网卡IPv4配置无法让他不变。&lt;/li&gt;
&lt;li&gt;ping &lt;a href=&#34;http://baidu.com/&#34;&gt;baidu.com&lt;/a&gt; 启动过程特别慢，估计跟DNS有关。&lt;/li&gt;
&lt;li&gt;VM设置静态IP，无法访问互联网，NAT就失效了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自定义nat网络&#34;&gt;自定义NAT网络&lt;/h3&gt;
&lt;p&gt;网络拓扑，摘自互联网。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/6EAD4887-1785-47EF-A527-7FF21A70F2DF.png&#34; alt=&#34;6EAD4887-1785-47EF-A527-7FF21A70F2DF&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hyper-V 管理器中创建一个新的交换机， 并在VM中启用这个交换机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7FF4F0E4-B0D8-4A2E-8D64-668837898471.png&#34; alt=&#34;7FF4F0E4-B0D8-4A2E-8D64-668837898471&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/D33768BD-BFD7-4D57-B6B4-CB9A82CDD4AF.png&#34; alt=&#34;D33768BD-BFD7-4D57-B6B4-CB9A82CDD4AF&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;定义一个C类网络，192.168.246.0，默认网关是192.168.246.1，这个网关地址也会在在物理机网卡上配置的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ubuntu 18 配置静态IP，搜索关键词Ubuntu netplan即可。不赘述。必须加上nameservers，使用默认的nameserver无法解析域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/6186B767-AD19-45FC-81F7-4D7E2DDB0116.png&#34; alt=&#34;6186B767-AD19-45FC-81F7-4D7E2DDB0116&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;把上面的网关地址填到Windows的这个虚拟网卡上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不是填网关地址，网络不通。所以，windows在这里的角色是网关的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7C3CCA08-E26D-46BE-8DBB-FD207C2AA497.png&#34; alt=&#34;7C3CCA08-E26D-46BE-8DBB-FD207C2AA497&#34;&gt;&lt;/p&gt;
&lt;p&gt;ifconfig/ipconfig如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/94315174-B7F8-4747-B042-555A903E28DA.png&#34; alt=&#34;94315174-B7F8-4747-B042-555A903E28DA&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;最后命令行设置NAT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一步最关键。决定了你是否能连互联网。不然只能局域网内连接了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;New-NetNat -Name NAT-VM -InternalIPInterfaceAddressPrefix 192.168.246.0/24
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hyper V NAT 网络设置 固定IP &lt;a href=&#34;https://www.cnblogs.com/wswind/p/11007613.html&#34;&gt;https://www.cnblogs.com/wswind/p/11007613.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用hyper-v搭建nat内部网络（与上篇雷同，太多命令行，容易误操作） &lt;a href=&#34;http://kael-aiur.com/%E9%BB%91%E7%A7%91%E6%8A%80/%E4%BD%BF%E7%94%A8hyper-v%E6%90%AD%E5%BB%BAnat%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C.html&#34;&gt;http://kael-aiur.com/%E9%BB%91%E7%A7%91%E6%8A%80/%E4%BD%BF%E7%94%A8hyper-v%E6%90%AD%E5%BB%BAnat%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遗留问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows VPN对NAT有影响，相当于断网了。&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/use-hyper-v/ - </description>
        </item>
    
    
    
        <item>
        <title>使用Go Modules</title>
        <link>https://xujiahua.github.io/posts/go-modules/</link>
        <pubDate>Fri, 28 Feb 2020 15:05:18 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/go-modules/</guid>
        <description>许嘉华的博客 https://xujiahua.github.io/posts/go-modules/ -&lt;p&gt;Go Modules使用着感觉不错，Go终于有正常点的依赖管理工具了。记录一二。&lt;/p&gt;
&lt;h2 id=&#34;使用小结&#34;&gt;使用小结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;go.mod, go.sum加入版本管理 Both go.mod and go.sum should be checked into version control.&lt;/li&gt;
&lt;li&gt;直接依赖体现在go.mod，间接依赖由直接依赖自己管理，这是个递归的过程 Only direct dependencies are recorded in the go.mod file.&lt;/li&gt;
&lt;li&gt;go命令自动管理go.mod，这可太方便了 When it encounters an import of a package not provided   by any module in go.mod, the go command automatically   looks up the module containing that package and adds it to   go.mod, using the latest version.&lt;/li&gt;
&lt;li&gt;看着比之前的依赖管理好用很多。比如dep。因为网络下载包等问题，最后把依赖包全checkin到vendor目录了。太臃肿。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod init&lt;/code&gt; creates a new module, initializing the go.mod file that describes it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt;,&lt;code&gt; go test&lt;/code&gt;, and other package-building commands add new dependencies to go.mod as needed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -m&lt;/code&gt; all prints the current module’s dependencies.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; changes the required version of a dependency (or adds a new dependency).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod tidy&lt;/code&gt; removes unused dependencies.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;p&gt;国内网络的问题，加上下面这行就好很多了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Set the GOPROXY environment variable
export GOPROXY=https://goproxy.io
&lt;/code&gt;&lt;/pre&gt;- https://xujiahua.github.io/posts/go-modules/ - </description>
        </item>
    
    
  </channel>
</rss> 