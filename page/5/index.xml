<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>许嘉华的笔记</title>
    <link>https://xujiahua.github.io/</link>
    <description>Recent content on 许嘉华的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 25 Apr 2021 13:18:00 +0800</lastBuildDate>
    
        <atom:link href="https://xujiahua.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Go Web 项目框架</title>
        <link>https://xujiahua.github.io/posts/20200320-go-web-project/</link>
        <pubDate>Fri, 20 Mar 2020 15:24:22 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200320-go-web-project/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200320-go-web-project/ -&lt;h2 id=&#34;常用开源库&#34;&gt;常用开源库&lt;/h2&gt;
&lt;h3 id=&#34;依赖包管理-go-modules&#34;&gt;依赖包管理 Go Modules&lt;/h3&gt;
&lt;p&gt;Go Modules。Go 从1.11版本开始支持，Go 1.14被认为是生产可用了。个人用过最方便的Go依赖包管理工具了。&lt;/p&gt;
&lt;p&gt;版本管理中维护 &lt;code&gt;go.mod&lt;/code&gt;/&lt;code&gt;go.sum&lt;/code&gt; 两个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320152954581.png&#34; alt=&#34;image-20200320152954581&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Using Go Modules &lt;a href=&#34;https://blog.golang.org/using-go-modules&#34;&gt;https://blog.golang.org/using-go-modules&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;命令行框架-corba&#34;&gt;命令行框架 Corba&lt;/h3&gt;
&lt;p&gt;Corba。第一次看到，是在翻看 Hyperledger Fabric 的时候。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/ad566232-814f-11e5-9cd0-aa101788c117.png&#34; alt=&#34;cobra logo&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子命令，嵌套的子命令。&lt;/li&gt;
&lt;li&gt;增强版本的flags。&lt;/li&gt;
&lt;li&gt;项目模板的生成工具。&lt;/li&gt;
&lt;li&gt;生成工具也自动引入了Viper这个包。Corba与Viper由一个作者开发，两个项目配合使用非常方便。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建议使用Cobra命令行工具生成项目模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ▾ appName/
    ▾ cmd/
        add.go
        your.go
        commands.go
        here.go
      main.go
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;参考-1&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A Commander for modern Go CLI interactions &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cobra Generator &lt;a href=&#34;https://github.com/spf13/cobra/blob/master/cobra/README.md&#34;&gt;https://github.com/spf13/cobra/blob/master/cobra/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置管理-viper&#34;&gt;配置管理 Viper&lt;/h3&gt;
&lt;p&gt;Viper。常常与Corba搭配使用。抄一段官方简介：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/998df88a-8151-11e5-9448-4736db51020d.png&#34; alt=&#34;viper logo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats. It supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setting defaults 设置默认值。示例：&lt;code&gt;viper.SetDefault(&amp;quot;subject&amp;quot;, &amp;quot;World&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;reading from JSON, TOML, YAML, HCL, envfile and Java properties config files 支持各种配置文件格式，TOML比较合我口味。在使用viper之前的配置文件读取方式，一般都是配置文件对应一个Go的model，通过反序列化读入程序。现在看来非常粗糙。&lt;/li&gt;
&lt;li&gt;live watching and re-reading of config files (optional)&lt;/li&gt;
&lt;li&gt;reading from environment variables 读取环境变量。代码和配置严格分离，配置文件算是一种不错的选择，12-Factor更推荐将应用的配置存储于环境变量中，参考：https://12factor.net/zh_cn/config&lt;/li&gt;
&lt;li&gt;reading from remote config systems (etcd or Consul), and watching changes 读配置中心。&lt;/li&gt;
&lt;li&gt;reading from command line flags 示例：&lt;code&gt;viper.BindPFlag(&amp;quot;subject&amp;quot;, helloCmd.Flags().Lookup(&amp;quot;subject&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;reading from buffer&lt;/li&gt;
&lt;li&gt;setting explicit values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Viper can be thought of as a registry for all of your applications configuration needs.&lt;/p&gt;
&lt;h4 id=&#34;关于读环境变量&#34;&gt;关于读环境变量&lt;/h4&gt;
&lt;p&gt;AutomaticEnv is a powerful helper especially when combined with SetEnvPrefix. When called, Viper will check for an environment variable any time a viper.Get request is made. &lt;strong&gt;It will apply the following rules. It will check for a environment variable with a name matching the key uppercased&lt;/strong&gt; and prefixed with the EnvPrefix if set.&lt;/p&gt;
&lt;p&gt;环境变量名是有要求的，默认是大写+下划线组合。如果设置了EnvPrefix，环境变量名需要加上前缀加下划线。&lt;/p&gt;
&lt;p&gt;vip.GetXXX(var) 这里的var倒是大小写随意的，因为viper内部统一小写处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200321181144230.png&#34; alt=&#34;image-20200321181144230&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果环境变量名并不满足组合怎么办呢。使用BindEnv，绑定key与环境变量名之间的关系，而不是使用默认的约定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BindEnv&lt;/code&gt; takes one or two parameters. The first parameter is the key name, the second is the name of the environment variable. The name of the environment variable is case sensitive. If the ENV variable name is not provided, then Viper will automatically assume that the ENV variable matches the following format: prefix + &amp;ldquo;_&amp;rdquo; + the key name in ALL CAPS. &lt;strong&gt;When you explicitly provide the ENV variable name (the second parameter), it does not automatically add the prefix.&lt;/strong&gt; For example if the second parameter is &amp;ldquo;id&amp;rdquo;, Viper will look for the ENV variable &amp;ldquo;ID&amp;rdquo;.&lt;/p&gt;
&lt;h4 id=&#34;参考-2&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Go configuration with fangs &lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;https://github.com/spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;日志-logrus&#34;&gt;日志 logrus&lt;/h3&gt;
&lt;p&gt;Logrus提供的日志功能很丰富。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/687474703a2f2f692e696d6775722e636f6d2f68546556776d4a2e706e67.png&#34; alt=&#34;:walrus:&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSON、TEXT格式输出。JSON很方便解析，配合ES存储日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;参考-3&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Structured, pluggable logging for Go. &lt;a href=&#34;https://github.com/sirupsen/logrus&#34;&gt;https://github.com/sirupsen/logrus&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由库--grollia-mux&#34;&gt;路由库  grollia mux&lt;/h3&gt;
&lt;p&gt;摘抄官方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/68747470733a2f2f636c6f75642d63646e2e7175657374696f6e61626c652e73657276696365732f676f72696c6c612d69636f6e2d36342e706e67.png&#34; alt=&#34;Gorilla Logo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Package &lt;code&gt;gorilla/mux&lt;/code&gt; implements a request router and dispatcher for matching incoming requests to their respective handler.&lt;/p&gt;
&lt;p&gt;The name mux stands for &amp;ldquo;HTTP request multiplexer&amp;rdquo;. Like the standard &lt;code&gt;http.ServeMux&lt;/code&gt;, &lt;code&gt;mux.Router&lt;/code&gt; matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It implements the &lt;code&gt;http.Handler&lt;/code&gt; interface so it is compatible with the standard &lt;code&gt;http.ServeMux&lt;/code&gt;. Go 提供的http.Handler 接口太具有扩展性了。&lt;/li&gt;
&lt;li&gt;Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers. 丰富的路由匹配规则，host、path、header、query string都可以。&lt;/li&gt;
&lt;li&gt;URL hosts, paths and query values can have variables with an optional regular expression.&lt;/li&gt;
&lt;li&gt;Registered URLs can be built, or &amp;ldquo;reversed&amp;rdquo;, which helps maintaining references to resources.&lt;/li&gt;
&lt;li&gt;Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching. 分组功能，RESTful接口按照实体分组，很实用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以搭配同系列的middleware项目使用：https://github.com/gorilla/handlers。&lt;/p&gt;
&lt;h4 id=&#34;参考-4&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A powerful HTTP router and URL matcher for building Go web servers &lt;a href=&#34;https://github.com/gorilla/mux&#34;&gt;https://github.com/gorilla/mux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A collection of useful middleware for Go HTTP services &amp;amp; web applications &lt;a href=&#34;https://github.com/gorilla/handlers&#34;&gt;https://github.com/gorilla/handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Web Server Graceful Shutdown &lt;a href=&#34;https://github.com/gorilla/mux#graceful-shutdown&#34;&gt;https://github.com/gorilla/mux#graceful-shutdown&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;orm-gorm&#34;&gt;ORM gorm&lt;/h3&gt;
&lt;p&gt;文档很丰富。功能很实用。摘抄官方文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full-Featured ORM (almost)&lt;/li&gt;
&lt;li&gt;Associations (Has One, Has Many, Belongs To, Many To Many, Polymorphism)&lt;/li&gt;
&lt;li&gt;Hooks (Before/After Create/Save/Update/Delete/Find)&lt;/li&gt;
&lt;li&gt;Preloading (eager loading)&lt;/li&gt;
&lt;li&gt;Transactions&lt;/li&gt;
&lt;li&gt;Composite Primary Key&lt;/li&gt;
&lt;li&gt;SQL Builder&lt;/li&gt;
&lt;li&gt;Auto Migrations 自动创建表结构。&lt;/li&gt;
&lt;li&gt;Logger&lt;/li&gt;
&lt;li&gt;Extendable, write Plugins based on GORM callbacks&lt;/li&gt;
&lt;li&gt;Every feature comes with tests&lt;/li&gt;
&lt;li&gt;Developer Friendly&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;参考-5&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;GORM Guides &lt;a href=&#34;https://gorm.io/docs/&#34;&gt;https://gorm.io/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;http-client-grequests&#34;&gt;HTTP client grequests&lt;/h3&gt;
&lt;p&gt;号称 Python Requests 的Go clone。用着不错。&lt;/p&gt;
&lt;h4 id=&#34;参考-6&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A Go &amp;ldquo;clone&amp;rdquo; of the great and famous Requests library &lt;a href=&#34;https://github.com/levigross/grequests&#34;&gt;https://github.com/levigross/grequests&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;errors-githubcompkgerrors&#34;&gt;Errors github.com/pkg/errors&lt;/h3&gt;
&lt;p&gt;内置的errors太弱了。返回了error，但是呢，没有返回上下文信息。这个库解决的是这个问题。&lt;/p&gt;
&lt;h4 id=&#34;参考-7&#34;&gt;参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Simple error handling primitives &lt;a href=&#34;https://github.com/pkg/errors&#34;&gt;https://github.com/pkg/errors&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;依赖注入框架-wire&#34;&gt;依赖注入框架 wire&lt;/h3&gt;
&lt;p&gt;基于代码生成的依赖注入框架。小项目没必要使用。&lt;/p&gt;
&lt;h3 id=&#34;rpc框架-grpc&#34;&gt;RPC框架 gRPC&lt;/h3&gt;
&lt;p&gt;跨进程，跨语言通信。&lt;/p&gt;
&lt;h2 id=&#34;常用工具&#34;&gt;常用工具&lt;/h2&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;p&gt;将常用的命令放在Makefile里管理。比如格式化代码 ，编译，打包，开发环境运行等等，并维护好依赖关系。&lt;/p&gt;
&lt;p&gt;不要写一堆.sh脚本了。&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;p&gt;维护一份Dockerfile，项目交付物通过制作成Docker镜像分发。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Dockerfile
FROM alpine:latest
WORKDIR /app
COPY ./dist .
ENTRYPOINT [&amp;quot;./app&amp;quot;, &amp;quot;serve&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过Docker来构建Go项目（一个两阶段的Dockerfile）。也可以像我这样，在宿主机就构建好，Dockerfile只需要COPY编译产物即可。&lt;/p&gt;
&lt;h3 id=&#34;swagger&#34;&gt;Swagger&lt;/h3&gt;
&lt;p&gt;目前没有方便的生成方法，得手写注释！&lt;/p&gt;
&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;Go web项目结构没有定式，每个人的风格都不一样。参考了这个系列文章，觉得不错，特别是第二篇。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go Web Application Structure - Part 1 &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-pt-1/&#34;&gt;https://aaf.engineering/go-web-application-structure-pt-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go Web Application Structure - Part 2 - Routing/Serving&lt;/strong&gt; &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-2/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Web Application Structure - Part 3 - The Database &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-3/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Web Application Structure - Part 4 - Database Migrations &amp;amp; Business Logic &lt;a href=&#34;https://aaf.engineering/go-web-application-structure-part-4/&#34;&gt;https://aaf.engineering/go-web-application-structure-part-4/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;code &lt;a href=&#34;https://github.com/theaaf/todos&#34;&gt;https://github.com/theaaf/todos&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;层级调用链：cmd -&amp;gt; api -&amp;gt; app -&amp;gt; db。model/config横切，其它层共享之。&lt;/p&gt;
&lt;h3 id=&#34;model-database-models&#34;&gt;model: database models&lt;/h3&gt;
&lt;p&gt;模型实体，通过分析需求建模，合理的建模便于后期维护。&lt;/p&gt;
&lt;p&gt;横切层。其他每层都会用到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170405357.png&#34; alt=&#34;image-20200320170405357&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;config&#34;&gt;config&lt;/h3&gt;
&lt;p&gt;横切层。&lt;/p&gt;
&lt;p&gt;并没有自己独立的包，而是其他每层都可以根据需要，有一个自己独立的Config结构体。通过一个全局的Viper变量，取出该层关心的配置变量（或是从配置文件，或是从环境变量）。&lt;/p&gt;
&lt;p&gt;比如数据层的config：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170301550.png&#34; alt=&#34;image-20200320170301550&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;db-database-operations&#34;&gt;db: database operations&lt;/h3&gt;
&lt;p&gt;数据持久化层，底层。CRUD操作的封装。通过“构造函数”做依赖注入，方便单元测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320170627650.png&#34; alt=&#34;image-20200320170627650&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;app-business-logic&#34;&gt;app: business logic&lt;/h3&gt;
&lt;p&gt;业务逻辑层，中层，核心层。调用数据层，及其他底层服务，比如S3云存储等。&lt;/p&gt;
&lt;h4 id=&#34;三类错误&#34;&gt;三类错误&lt;/h4&gt;
&lt;p&gt;该层方法返回的错误可以分三类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ValidationError 输入不正确，校验不通过，比如手机号长度不对。对应的HTTP状态码：400。&lt;/li&gt;
&lt;li&gt;UserError 认证错误，比如用户登录失败，用户没有权限。对应的HTTP状态码：401, 403。&lt;/li&gt;
&lt;li&gt;ServerError 系统错误，比如数据库连不上，也不需要特别定义ServerError：只要error不是ValidationError，UserError，就是ServerError。对应的HTTP状态码：500。&lt;/li&gt;
&lt;li&gt;没有错误，那么对应的HTTP状态码就是200。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;api-api-controllers&#34;&gt;api: api controllers&lt;/h3&gt;
&lt;p&gt;接口层。尽可能轻量，尽可能没有业务逻辑，只负责转译。通过调用业务逻辑层完成任务。将上述三分类错误映射到合适的状态码。&lt;/p&gt;
&lt;h4 id=&#34;application-state-vs-request-state&#34;&gt;Application State vs. Request State&lt;/h4&gt;
&lt;p&gt;请求入口函数需要为每个请求创建一个context（上下文）。context包含如下，摘抄原文。包含的字段需满足完成request的所需。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200320181127465.png&#34; alt=&#34;image-20200320181127465&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;request-context-请求上下文信息&#34;&gt;(Request) Context 请求上下文信息&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Remote IP地址，显示于access log。使用logrus.WithField()。&lt;/li&gt;
&lt;li&gt;Request ID，显示于access log。使用logrus.WithField()。&lt;/li&gt;
&lt;li&gt;User，用于后续鉴权。如果有认证头信息（Auth Token），从数据库取出用户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cmd-command-line-methods&#34;&gt;cmd: command line methods&lt;/h3&gt;
&lt;p&gt;使用Cobra生成子命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app serve &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动web server，并加入web server优雅退出的功能。&lt;/p&gt;
- https://xujiahua.github.io/posts/20200320-go-web-project/ - </description>
        </item>
    
    
    
        <item>
        <title>Go库对URL Path中%2F的处理</title>
        <link>https://xujiahua.github.io/posts/20200312-slash-in-url-path/</link>
        <pubDate>Thu, 12 Mar 2020 15:17:36 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200312-slash-in-url-path/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200312-slash-in-url-path/ -&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;有同事反馈Go项目的接口404了。看了下nginx日志，只有部分请求404了，404请求的显著特征是URL里有&lt;code&gt;%2F&lt;/code&gt;，也就是&lt;code&gt;/&lt;/code&gt;的转义。&lt;/li&gt;
&lt;li&gt;接口定义是这样的：&lt;code&gt;/api/xxx/{mid}/{uid}&lt;/code&gt;。mid、uid是URL path的一部分。从现象来看，程序没处理好转义字符，因为多了一个path部分，路由不匹配了，404。&lt;/li&gt;
&lt;li&gt;nginx的URL记录是&lt;code&gt;%2F&lt;/code&gt;，其实调用方传的是微信ID，比如&lt;code&gt;IEd5W/jqsdF9qpuagQscEg==&lt;/code&gt;。调用方在发请求之前对ID已经做好了转义。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;go内置库不区分2f和&#34;&gt;Go内置库：不区分&lt;code&gt;%2F&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;An application cannot distinguish between &amp;ldquo;/&amp;rdquo; used as a path segment delimiter and &amp;ldquo;/&amp;rdquo; encoded in a path segment.&lt;/p&gt;
&lt;p&gt;这个问题由来已久了，看着官方也不打算解决了，见这个issue：https://github.com/golang/go/issues/3659&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;If your app needs to assign special meaning, the
server can reprocess req.RequestURI as it sees fit, and the client can
issue requests using &amp;amp;url.URL{Opaque: rawURI}.
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;reprocess req.RequestURI 就是让你别用内置路由库了。&lt;/li&gt;
&lt;li&gt;issue requests using &amp;amp;url.URL{Opaque: rawURI}. 试了，问题没解决。客户端不管怎么做，最终都是以HTTP协议输出的。&lt;code&gt;GET http://www.google.com/index.html HTTP/1.1&lt;/code&gt; 服务端代码最终解析的还是中间的那段URL文本。照理就不通啊。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;源码角度&#34;&gt;源码角度&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;url.URL&lt;/code&gt;的定义，明确指出Path字段存储的是decode之后的数据，所以&lt;code&gt;%2F&lt;/code&gt;在这里已经被转义成了&lt;code&gt;/&lt;/code&gt;，跟之前的Path意义完全不同了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312154454662.png&#34; alt=&#34;image-20200312154454662&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http.ServeMux&lt;/code&gt;也是依赖Path进行路由的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312155554309.png&#34; alt=&#34;image-20200312155554309&#34;&gt;&lt;/p&gt;
&lt;p&gt;而http.Request中的URL字段是怎么从HTTP协议中解析出来的呢，从http.ListenAndServe顺藤摸瓜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312163138455.png&#34; alt=&#34;image-20200312163138455&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后还是在parse rawurl字符串，红框里会做path的转义操作，坑之所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312164058458.png&#34; alt=&#34;image-20200312164058458&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用Go内置的http路由，代码都写死了：URL解析代码中，Path一定是decode后的数据；路由代码中使用Path来路由。问题得不到解决。&lt;/p&gt;
&lt;h2 id=&#34;gorillamux-useencodedpath&#34;&gt;gorilla/mux: UseEncodedPath()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.gorillatoolkit.org/pkg/mux&#34;&gt;http://www.gorillatoolkit.org/pkg/mux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312170420310.png&#34; alt=&#34;image-20200312170420310&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用这个方法就可以基于encoded Path进行路由了。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/http/httptest&amp;quot;

	&amp;quot;github.com/gorilla/mux&amp;quot;
)

func main() {
	router := mux.NewRouter().UseEncodedPath() # 创建router的时候设置
	router.NewRoute().Name(&amp;quot;test&amp;quot;).Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/test/{name}&amp;quot;).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, mux.Vars(r))
	})
	server := httptest.NewServer(router)
	defer server.Close()

	res, err := http.Get(server.URL + &amp;quot;/test/bob%2Fvanderlen&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	greeting, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&amp;quot;%s&amp;quot;, greeting)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;源码角度-1&#34;&gt;源码角度&lt;/h3&gt;
&lt;p&gt;通过flag来控制是否用encode过的还是decode过的Path。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312171317394.png&#34; alt=&#34;image-20200312171317394&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;还不完美&#34;&gt;还不完美&lt;/h2&gt;
&lt;p&gt;期望取到的数据是&lt;code&gt; IEd5W/jqsdF9qpuagQscEg==&lt;/code&gt;。然而，Path变量的取值仍然是根据标志位来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312173633090.png&#34; alt=&#34;image-20200312173633090&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，即使让请求找到了路由，还是取不到真正的值。还得对URL Path进行手动decode才能用其中的值。让人崩溃，好多地方要改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312174326015.png&#34; alt=&#34;image-20200312174326015&#34;&gt;&lt;/p&gt;
&lt;p&gt;不完美，但至少不需要让调用者改代码了。以后接口设计还是把请求参数放Body里，稳一点。&lt;/p&gt;
- https://xujiahua.github.io/posts/20200312-slash-in-url-path/ - </description>
        </item>
    
    
    
        <item>
        <title>专利申请流程小结</title>
        <link>https://xujiahua.github.io/posts/20200311-patent/</link>
        <pubDate>Wed, 11 Mar 2020 11:25:09 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200311-patent/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200311-patent/ -&lt;p&gt;去年憋的一篇专利，到申请公布阶段了，算是去年研究区块链的副成果。https://patents.google.com/patent/CN110807211。整理下专利申请流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/01C8BAF0-B9C7-4F08-9575-38AF85AC4F14.png&#34; alt=&#34;01C8BAF0-B9C7-4F08-9575-38AF85AC4F14&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;专利申请流程&#34;&gt;专利申请流程&lt;/h2&gt;
&lt;p&gt;主要流程如下图，来自网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7CA0DB1A-692F-481B-BFA3-987F503E1E39.png&#34; alt=&#34;7CA0DB1A-692F-481B-BFA3-987F503E1E39&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;技术成果生成&#34;&gt;技术成果生成&lt;/h3&gt;
&lt;p&gt;有可以申请专利的点，这个因人而异。基于点子，写个草稿。&lt;/p&gt;
&lt;h3 id=&#34;申请专利&#34;&gt;申请专利&lt;/h3&gt;
&lt;p&gt;找一个专利代理，让他们提供专利稿的修改意见。反复迭代直到专利代理觉得没问题了。&lt;/p&gt;
&lt;p&gt;之后专利代理会出具一份「专利申请受理通知书」，你再交点钱，可能还会有税费减免。&lt;/p&gt;
&lt;p&gt;我遇到了专利代理看不大懂专利的情况，僵持了一段时间，后面换了一家顺畅好多。&lt;/p&gt;
&lt;h3 id=&#34;专利申请公布&#34;&gt;专利申请公布&lt;/h3&gt;
&lt;p&gt;这个时间点叫做：申请公布日。&lt;/p&gt;
&lt;p&gt;说明初审过了。实用新型和外观发明的话，直接就授权了，而发明还需要实质审查。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;初步审查合格后，实用新型和外观就直接授权了，而发明还要经过实质审查，检索国内外的资料，确认没有相同的才会授权，所以发明的含金量会高很多，因此发明专利审查的时间也会是比较长的，一般从申请到拿证书都需要2-3年，而实用、外观这两项专利一年能拿到。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;专利授权公告&#34;&gt;专利授权公告&lt;/h3&gt;
&lt;p&gt;这个时间点叫做：授权公告日。&lt;/p&gt;
&lt;p&gt;说明正式审查完了。这时候才算是真正拥有专利。&lt;/p&gt;
- https://xujiahua.github.io/posts/20200311-patent/ - </description>
        </item>
    
    
    
        <item>
        <title>Github pages重新开始：使用Hugo、Typora</title>
        <link>https://xujiahua.github.io/posts/20200310-github-pages-restart/</link>
        <pubDate>Tue, 10 Mar 2020 11:24:49 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200310-github-pages-restart/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200310-github-pages-restart/ -&lt;h2 id=&#34;重新开始github-pages&#34;&gt;重新开始GitHub pages&lt;/h2&gt;
&lt;p&gt;曾使用&lt;code&gt;GitHub pages&lt;/code&gt; + &lt;code&gt; jekyll&lt;/code&gt; 写过一段时间博客，没啥营养。&lt;/p&gt;
&lt;p&gt;打算重新开始：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把我记录在Evernote和Typora中的资料迁移到&lt;code&gt;GitHub pages&lt;/code&gt;上。&lt;/li&gt;
&lt;li&gt;另外做一些Web形式的小工具，挂载在一个子目录里，方便平时使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hugo--typora&#34;&gt;Hugo + Typora&lt;/h2&gt;
&lt;p&gt;打算如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Markdown文件还是使用Typora写。用过MWeb、Typora，Typora使用感受更好些（这么好用还不要钱）。&lt;/li&gt;
&lt;li&gt;Hugo作为静态网站生成，创建一个博客模板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hugo-quickstart&#34;&gt;Hugo quickstart&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 安装hugo（其实是Go编译的二进制文件）
brew install hugo

# 创建site
hugo new site quickstart

# 通过git submodule的方式下载主题
git init
git submodule -b master add https://github.com/dillonzq/LoveIt themes/LoveIt

# 更新config.toml，配置主题参数，见loveit配置

# 创建博客，创建的posts在content目录下。文件格式为：content/&amp;lt;CATEGORY&amp;gt;/&amp;lt;FILE&amp;gt;.&amp;lt;FORMAT&amp;gt;
# hugo new 会采用 archetypes/default.md作为模板，把一些共性配置放在这个模板里吧。
hugo new posts/my-first-post.md

# 本地看blog效果，-D表示草稿状态的博客也显示
hugo server -D

# 生成静态网站到./public/，也可以指定目录
hugo -D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挑选了一个比较实用的主题 &lt;a href=&#34;https://hugoloveit.com/&#34;&gt;https://hugoloveit.com/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较基本的posts, tags, categories&lt;/li&gt;
&lt;li&gt;文章页面右边可显示文章的目录表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hugoloveit.com/theme-documentation-basics/&#34;&gt;https://hugoloveit.com/theme-documentation-basics/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;图片文件夹的配置&#34;&gt;图片文件夹的配置&lt;/h3&gt;
&lt;p&gt;Typora的贴图功能很方便：配置好图片文件夹，从剪贴板粘贴图像会自动将图片保存到图片文件夹，并自动命名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt;管理静态资源的方式跟Typora默认是不适配的，需要做些调整。&lt;/p&gt;
&lt;h5 id=&#34;长话短说&#34;&gt;长话短说&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;项目中，创建&lt;code&gt;static/images&lt;/code&gt;文件夹，并且软链接到项目根目录下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p static/images &amp;amp;&amp;amp; ln -s `pwd`/static/images images
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Typora打开content目录，并做配置如下。之后，像平常那样用Typora写文字吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200310184153667.png&#34; alt=&#34;image-20200310184153667&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;在根目录建images软链接的理由&#34;&gt;在根目录建&lt;code&gt;images&lt;/code&gt;软链接的理由&lt;/h5&gt;
&lt;p&gt;一些信息和思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;的静态资源放在static目录下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;生成静态文件，static目录会将其下的文件、文件夹平移到目标网站目录的根目录，比如&lt;code&gt;static/images/1.png&lt;/code&gt;，平移后为&lt;code&gt;images/1.png&lt;/code&gt;。html里使用&lt;code&gt;/images/*&lt;/code&gt;的方式引用。（可查看public文件夹的目录结构）&lt;/li&gt;
&lt;li&gt;hugo static目录下的资源目录不能是软链接，WTF。Unsupported symlink found &lt;a href=&#34;https://github.com/gohugoio/hugo/issues/6225&#34;&gt;https://github.com/gohugoio/hugo/issues/6225&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;万幸Typora可以用软链接。&lt;/li&gt;
&lt;li&gt;一篇post，在浏览器和文件系统上的目录结构是不同的。以最末层的文件夹为&lt;code&gt;./&lt;/code&gt;。浏览器下目录结构如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;/ =&amp;gt; ../.. 举例来说，以图片文件夹名称为`image`为例，`../../images/*` = `/images/*`
	/posts/ =&amp;gt; ../
		/posts/post_name/ =&amp;gt; ./
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;文件系统下的目录结构：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;hugo-blogger =&amp;gt; ../../
	content =&amp;gt; ../
		posts =&amp;gt; ./
			post_name
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;所以为了能让文件系统和浏览器上都显示图像，&lt;code&gt;images&lt;/code&gt;软链接放在项目根目录下比较合适。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;github-pages&#34;&gt;GitHub pages&lt;/h3&gt;
&lt;p&gt;静态文件输出到xujiahua.github.io上去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule add -b master https://github.com/XUJiahua/XUJiahua.github.io.git public
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复用这里的deploy脚本。https://gohugo.io/hosting-and-deployment/hosting-on-github/#put-it-into-a-script&lt;/p&gt;
&lt;h4 id=&#34;图片资源404的问题&#34;&gt;图片资源404的问题&lt;/h4&gt;
&lt;p&gt;_images文件夹下的资源404了。太奇怪了，路径OK，也没大小问题。过了很久还是不见效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20200312190900210.png&#34; alt=&#34;image-20200312190900210&#34;&gt;&lt;/p&gt;
&lt;p&gt;尝试在images文件夹下放了个1.txt，理论上链接应该是 &lt;a href=&#34;https://xujiahua.github.io/images/1.txt&#34;&gt;https://xujiahua.github.io/images/1.txt&lt;/a&gt;，一开始也是404。过了半小时OK了。&lt;/p&gt;
&lt;p&gt;结论是，_images文件夹取名可能有问题。那就改用images。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34;&gt;https://gohugo.io/hosting-and-deployment/hosting-on-github/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/20200310-github-pages-restart/ - </description>
        </item>
    
    
    
        <item>
        <title>Hyper-V使用体验</title>
        <link>https://xujiahua.github.io/posts/20200323-use-hyper-v/</link>
        <pubDate>Tue, 03 Mar 2020 22:13:23 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200323-use-hyper-v/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200323-use-hyper-v/ -&lt;h2 id=&#34;hyper-v-使用体验&#34;&gt;Hyper-V 使用体验&lt;/h2&gt;
&lt;p&gt;Hyper-V是 Windows10 内置的虚拟机软件，没想到我会用到它。&lt;/p&gt;
&lt;h3 id=&#34;为什么要用hyper-v&#34;&gt;为什么要用Hyper-V&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要使用虚拟机来模拟Kubernetes环境。&lt;/li&gt;
&lt;li&gt;Windows Docker依赖Hyper-V。貌似WSL2也是基于Hyper-V。应该是不会卸载Hyper-V了。&lt;/li&gt;
&lt;li&gt;Hyper-V与其他虚拟机软件（VirtualBox, VMWare）冲突，用不了其他的，只能用Hyper-V。&lt;/li&gt;
&lt;li&gt;Hyper-V与VirtualBox兼容的方案有没有。可能有，不想过于折腾了，那就不得不用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hyper-v好不好用&#34;&gt;Hyper-V好不好用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用体验太差了，从Mac、从其他虚拟机使用过来，默认配置各种踩坑。&lt;/li&gt;
&lt;li&gt;安装VM碰到DHCP超时的问题，反复试验无果，重启Windows后VM的DHCP不超时了。总结下，Windows上，如果怎么搞都搞不定，重启下可能就好了。WTF！&lt;/li&gt;
&lt;li&gt;自带的NAT网络有点残疾，VM配置静态IP，网络就不通了。不像VirtualBox是开箱即用的。&lt;/li&gt;
&lt;li&gt;最后借助网络上的零碎信息自定义了下NAT网络，各种神奇配置。&lt;/li&gt;
&lt;li&gt;Windows还是很屎，除了打游戏，开发体验跟我之前的体验一样糟。最后搞定花了我一天时间。要是用VMware/VirtualBox，可能在2个小时内就能搞定。总结，不好用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hyper-v-创建和克隆vm&#34;&gt;Hyper-V 创建和克隆VM&lt;/h2&gt;
&lt;h3 id=&#34;创建vm&#34;&gt;创建VM&lt;/h3&gt;
&lt;p&gt;从&lt;code&gt;*.iso&lt;/code&gt;文件创建VM。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/465F25A3-07A1-4DB7-90CE-FD02376D4C92.png&#34; alt=&#34;465F25A3-07A1-4DB7-90CE-FD02376D4C92&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意，Linux VM，不启用Windows Secure Boot。&lt;/li&gt;
&lt;li&gt;更多选项里，设置VM的名称和交换机。&lt;/li&gt;
&lt;li&gt;体验不好的地方：左上方的「选择操作系统」区域有长时间的加载过程，即使使用本地镜像文件也得等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;克隆vm&#34;&gt;克隆VM&lt;/h3&gt;
&lt;p&gt;从硬盘文件创建VM。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/03603F71-9B97-4ABC-8D1F-91F6CBB6602E.png&#34; alt=&#34;03603F71-9B97-4ABC-8D1F-91F6CBB6602E&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/3C85F0B5-0763-468F-9ABC-2FC35AF20235.png&#34; alt=&#34;3C85F0B5-0763-468F-9ABC-2FC35AF20235&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;克隆是为了减少重复配置一些基础环境的工作量。&lt;/li&gt;
&lt;li&gt;不像VirtualBox那样有直观的克隆按钮。摸索出的克隆功能是这样的：就是从VM硬盘创建VM。&lt;/li&gt;
&lt;li&gt;建议先关机母体VM后，再基于母体VM的硬盘文件克隆。防止母体VM开机状态下一些更新并没有持久化到硬盘文件中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hyper-v-nat网络搭建总结&#34;&gt;Hyper-V NAT网络搭建总结&lt;/h2&gt;
&lt;p&gt;如果使用VMWare/VirtualBox的话，NAT网络是完全自动搭建的。&lt;/p&gt;
&lt;p&gt;VMWare中有三种网络模式，Bridging、NAT、Host-only分别对应Hyper-V下的三种交换机，外部、内部、专用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bridging：VM使用物理网络。GUEST VM与HOST相当于通过交换机连上一个网络（细节不确定）。&lt;/li&gt;
&lt;li&gt;NAT：VM使用虚拟网络，HOST同时连入物理网络和虚拟网络。VM出口流量都会通过HOST，使用HOST IP。&lt;/li&gt;
&lt;li&gt;Host-only：在NAT基础上，VM连不上外网，除非有路由设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;默认的nat网络&#34;&gt;默认的NAT网络&lt;/h3&gt;
&lt;p&gt;默认交换机支持NAT，但是瑕疵不少，无法满足工作需要。&lt;/p&gt;
&lt;p&gt;Hyper-V Default Switch + VM DHCP 的组合默认有了NAT功能，满足以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机之间可以互相访问&lt;/li&gt;
&lt;li&gt;虚拟机与物理机之间可以互相访问&lt;/li&gt;
&lt;li&gt;虚拟机可以访问互联网&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次重启，Default Switch的IP都会变，Windows10 物理机上的网卡IPv4配置无法让他不变。&lt;/li&gt;
&lt;li&gt;ping &lt;a href=&#34;http://baidu.com/&#34;&gt;baidu.com&lt;/a&gt; 启动过程特别慢，估计跟DNS有关。&lt;/li&gt;
&lt;li&gt;VM设置静态IP，无法访问互联网，NAT就失效了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自定义nat网络&#34;&gt;自定义NAT网络&lt;/h3&gt;
&lt;p&gt;网络拓扑，摘自互联网。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/6EAD4887-1785-47EF-A527-7FF21A70F2DF.png&#34; alt=&#34;6EAD4887-1785-47EF-A527-7FF21A70F2DF&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hyper-V 管理器中创建一个新的交换机， 并在VM中启用这个交换机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7FF4F0E4-B0D8-4A2E-8D64-668837898471.png&#34; alt=&#34;7FF4F0E4-B0D8-4A2E-8D64-668837898471&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/D33768BD-BFD7-4D57-B6B4-CB9A82CDD4AF.png&#34; alt=&#34;D33768BD-BFD7-4D57-B6B4-CB9A82CDD4AF&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;定义一个C类网络，192.168.246.0，默认网关是192.168.246.1，这个网关地址也会在在物理机网卡上配置的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ubuntu 18 配置静态IP，搜索关键词Ubuntu netplan即可。不赘述。必须加上nameservers，使用默认的nameserver无法解析域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/6186B767-AD19-45FC-81F7-4D7E2DDB0116.png&#34; alt=&#34;6186B767-AD19-45FC-81F7-4D7E2DDB0116&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;把上面的网关地址填到Windows的这个虚拟网卡上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不是填网关地址，网络不通。所以，windows在这里的角色是网关的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/7C3CCA08-E26D-46BE-8DBB-FD207C2AA497.png&#34; alt=&#34;7C3CCA08-E26D-46BE-8DBB-FD207C2AA497&#34;&gt;&lt;/p&gt;
&lt;p&gt;ifconfig/ipconfig如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/94315174-B7F8-4747-B042-555A903E28DA.png&#34; alt=&#34;94315174-B7F8-4747-B042-555A903E28DA&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;最后命令行设置NAT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一步最关键。决定了你是否能连互联网。不然只能局域网内连接了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;New-NetNat -Name NAT-VM -InternalIPInterfaceAddressPrefix 192.168.246.0/24
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hyper V NAT 网络设置 固定IP &lt;a href=&#34;https://www.cnblogs.com/wswind/p/11007613.html&#34;&gt;https://www.cnblogs.com/wswind/p/11007613.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用hyper-v搭建nat内部网络（与上篇雷同，太多命令行，容易误操作） &lt;a href=&#34;http://kael-aiur.com/%E9%BB%91%E7%A7%91%E6%8A%80/%E4%BD%BF%E7%94%A8hyper-v%E6%90%AD%E5%BB%BAnat%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C.html&#34;&gt;http://kael-aiur.com/%E9%BB%91%E7%A7%91%E6%8A%80/%E4%BD%BF%E7%94%A8hyper-v%E6%90%AD%E5%BB%BAnat%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遗留问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows VPN对NAT有影响，相当于断网了。&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/20200323-use-hyper-v/ - </description>
        </item>
    
    
    
        <item>
        <title>使用Go Modules</title>
        <link>https://xujiahua.github.io/posts/20200228-go-modules/</link>
        <pubDate>Fri, 28 Feb 2020 15:05:18 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200228-go-modules/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200228-go-modules/ -&lt;p&gt;Go Modules使用着感觉不错，Go终于有正常点的依赖管理工具了。记录一二。&lt;/p&gt;
&lt;h2 id=&#34;使用小结&#34;&gt;使用小结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;go.mod, go.sum加入版本管理 Both go.mod and go.sum should be checked into version control.&lt;/li&gt;
&lt;li&gt;直接依赖体现在go.mod，间接依赖由直接依赖自己管理，这是个递归的过程 Only direct dependencies are recorded in the go.mod file.&lt;/li&gt;
&lt;li&gt;go命令自动管理go.mod，这可太方便了 When it encounters an import of a package not provided   by any module in go.mod, the go command automatically   looks up the module containing that package and adds it to   go.mod, using the latest version.&lt;/li&gt;
&lt;li&gt;看着比之前的依赖管理好用很多。比如dep。因为网络下载包等问题，最后把依赖包全checkin到vendor目录了。太臃肿。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod init&lt;/code&gt; creates a new module, initializing the go.mod file that describes it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt;,&lt;code&gt; go test&lt;/code&gt;, and other package-building commands add new dependencies to go.mod as needed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -m&lt;/code&gt; all prints the current module’s dependencies.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; changes the required version of a dependency (or adds a new dependency).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod tidy&lt;/code&gt; removes unused dependencies.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;p&gt;国内网络的问题，加上下面这行就好很多了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Set the GOPROXY environment variable
export GOPROXY=https://goproxy.io
&lt;/code&gt;&lt;/pre&gt;- https://xujiahua.github.io/posts/20200228-go-modules/ - </description>
        </item>
    
    
    
        <item>
        <title>5G认识小结</title>
        <link>https://xujiahua.github.io/posts/20200222-5g/</link>
        <pubDate>Sat, 22 Feb 2020 23:32:14 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200222-5g/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200222-5g/ -&lt;p&gt;去年11月尝鲜，买了个三星5G手机。找基站测5G速度成了刚买时候的乐趣。用了几个月，深感5G功能很鸡肋，5G基站太少。&lt;/p&gt;
&lt;p&gt;这两天翻了好多知乎上关于5G的评论，对5G的概念、应用场景有了些厘清。&lt;/p&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;5G，第五代移动通信技术。也就是5G的边界是移动通信网络。&lt;/li&gt;
&lt;li&gt;5G的直接作用是提高了移动设备到基站的下载速率，能达到1G/s，也就是所谓的空口延迟低。&lt;/li&gt;
&lt;li&gt;5G下载的速度上限还是光纤的下载速度上限。&lt;/li&gt;
&lt;li&gt;5G的流量套餐应该不会便宜，除非国家出政策。为什么套餐不会便宜，这得看成本。5G的基站建设成本远比4G高。5G基站覆盖面积小，需要几倍于4G的基站，5G基站耗电成本也是几倍于4G基站。肥了设备商（华为中兴），苦了运营商（移动联通电信），最后还是消费者买单。&lt;/li&gt;
&lt;li&gt;理论速度极可能跑不满。使用者多了，平均到每个终端，带宽就不够。现在我的4G速度好慢，完全没到理论速度。现在的矛盾不是需要更快的网络，而是更多的网络。&lt;/li&gt;
&lt;li&gt;木桶效应，一个桶能装多少水由短板决定，以前的移动通信是短板，但是通过3G、4G到现在的5G的改善，已经成为长板了。运营商的承载网等配套也得扩容。不然5G的超高下载速率就是一个理论值。又是运营商的成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;大部分人的共识是，5G的杀手级应用仍在探索中。&lt;/p&gt;
&lt;p&gt;什么样的场景，只有通过5G能够做到，而其他技术不行，这样的场景就是典型的5G应用场景。要找到技术的适用场景，不能生搬硬套。区块链也是这样一个典型。过滤那些“可以使用XXX技术，但是完全没必要”的场景。&lt;/p&gt;
&lt;p&gt;媒体上关于5G的一些应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程手术 —— 为什么不用光纤，可靠性更好。如果是边远山区不方便铺光纤，5G可能是好的替代。有总比没有好。&lt;/li&gt;
&lt;li&gt;远程挖掘机 —— 微博上看到的，挖掘机通过5G联网，驾驶员在机房操控，安全性更高。&lt;/li&gt;
&lt;li&gt;远程办公、远程上课 —— 这些光纤都能做到。对于山村里不方便通光纤的，是好事。但是山村里的困难是超乎我们想象的。看新闻，因为疫情不得不在家上课，几个小孩子共用一个手机，流量又贵，不舍得用。太难了。&lt;/li&gt;
&lt;li&gt;AR/VR —— 不看好。光纤，百兆宽带都这么普及了，AR/VR发展不好的根本原因应该是AR/VR本身吧，5G救不了ARVR。&lt;/li&gt;
&lt;li&gt;无人驾驶 —— 不看好。移动通信中的延时一直保持很低很困难吧，比如短时间太多人/设备使用基站导致拥挤。可靠性太重要了，毕竟汽车是高速移动的，稍微的疏忽就是惨痛代价。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;会不会带来下一个移动互联网&#34;&gt;会不会带来下一个“移动互联网”&lt;/h2&gt;
&lt;p&gt;之所以大家对5G这么关注，就是在想，5G能否像3/4G一样带动下一个移动互联网（电商、O2O、移动支付、短视频、直播）。&lt;/p&gt;
&lt;p&gt;先来看看移动互联网是怎么发展起来的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;苹果公司发布iPhone，智能手机的火种。&lt;/li&gt;
&lt;li&gt;小米等一众国产品牌的低价策略，带来了&lt;strong&gt;智能手机的普及&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;国务院要求&lt;strong&gt;运营商资费下降&lt;/strong&gt;。大家都用得起流量。&lt;/li&gt;
&lt;li&gt;总结就是：智能手机普及 + 运营商资费下降。&lt;/li&gt;
&lt;li&gt;其中智能手机，这是从无到有，从0到1的奇迹，颠覆了之前的所有手机。（好久没有让人激动的科技产品了，苹果的创新能力也是在备受质疑，因为大家期望太高了。）&lt;/li&gt;
&lt;li&gt;其中运营商资费下降，这是国家权力。（知乎用户：钱都让互联网企业赚走了，通讯行业等同于修路。）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5G目前的作用仅限于加快了与基站之间的通信速度，假如说3G完成了从0到1，4G完成了从1到10，那么5G是从10到100吧。根据边际效应准则，后面的收益会越来越少。&lt;/p&gt;
&lt;p&gt;很难看出能带来什么样的产业革命来。&lt;/p&gt;
&lt;h2 id=&#34;5g的利益关系&#34;&gt;5G的利益关系&lt;/h2&gt;
&lt;p&gt;利好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;5G基站厂商。华为为主。&lt;/li&gt;
&lt;li&gt;国家层面。5G是国家战略，是政治正确。其一，靠专利技术薅世界羊毛，从国家角度是有利可图的。其二，带动产业发展，拉动GDP。&lt;/li&gt;
&lt;li&gt;手机终端厂商。近年来手机上的创新的吸睛能力真不行，消费欲望降低。靠5G这个卖点，能赚一波眼球。&lt;/li&gt;
&lt;li&gt;还有众多蹭5G话题流量的：广告公司、创业公司。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利坏：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三大运营商。基站投入是高成本的，为了发展5G生态，国家也会限制套餐费用，影响其收入。还好是国企。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：https://www.zhihu.com/question/342366514/answer/820922564&lt;/p&gt;
&lt;h2 id=&#34;杂言&#34;&gt;杂言&lt;/h2&gt;
&lt;p&gt;真正有颠覆性的，真正能突破人们想象力的，都在基础科学。比如材料科学，电池技术现在是瓶颈。离我很远。我做的事情真的对人类价值不大，只是个普通人，只能做到赚钱养家对家庭做贡献了。&lt;/p&gt;
- https://xujiahua.github.io/posts/20200222-5g/ - </description>
        </item>
    
    
    
        <item>
        <title>Implicit：推荐系统协同过滤库的测评</title>
        <link>https://xujiahua.github.io/posts/20200211-recsys-implicit/</link>
        <pubDate>Tue, 11 Feb 2020 14:34:27 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20200211-recsys-implicit/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20200211-recsys-implicit/ -&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Implicit是一个推荐系统协同过滤库。所谓协同过滤，只用到了user、item的ID和user、item交互后的评分（或是某个度量）。&lt;/p&gt;
&lt;p&gt;GitHub：https://github.com/benfred/implicit&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pip install implicit
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;其他选择&#34;&gt;其他选择&lt;/h2&gt;
&lt;p&gt;自己照着「推荐系统实战」里的基于物品推荐的相似度公式（类似关联分析中的Lift公式），也写了一个item-item recommender。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看推荐结果，自己写与implicit ALS有点差别，与implicit Cosine的结果差不多。&lt;/li&gt;
&lt;li&gt;纯python，没有并行，没有用C/C++，果然很慢。&lt;/li&gt;
&lt;li&gt;自己写一个的目的，除了练手，也想看看implicit的效果具体怎么样。&lt;/li&gt;
&lt;li&gt;生产使用，不建议用自己手写的，水平真的有限。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Spark Mllib怎么样。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spark Mllib支持分布式，感觉没必要。本来Implicit单机就很强了。只要把数据导出来，导到训练机器上即可。&lt;/li&gt;
&lt;li&gt;Spark分布式，扩展性好，但是性能并没有Implicit那么好。&lt;/li&gt;
&lt;li&gt;Spark还得搭配HDFS，真的蛮重的，开发效率也没那么好。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;背后的原理&#34;&gt;背后的原理&lt;/h2&gt;
&lt;p&gt;今早根据作者文章Distance Metrics for Fun and Profit，整理了一份读后感，把之前的知识给梳理起来了。这篇文章主要介绍的是距离公式，用于K近邻的推荐算法。&lt;/p&gt;
&lt;p&gt;协同过滤算法分两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于记忆的，K近邻算法（基于“距离”公式），建议使用BM25。优势在读后感中有写。（实际效果怎么样，还得看数据）&lt;/li&gt;
&lt;li&gt;基于模型的，矩阵分解算法，建议使用 (implicit) ALS，其变种是支持implicit dataset的。矩阵分解算法SGD，只适用于评分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;效果，见测评图。ALS的效果是最好的了。这是在movielens100k的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/3D66F424-97FD-4236-8A57-98111FAF65A7.png&#34; alt=&#34;3D66F424-97FD-4236-8A57-98111FAF65A7&#34;&gt;&lt;/p&gt;
&lt;p&gt;看起来指标都很低，「推荐系统实战」里差不多这个结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/FBC00415-D1AE-4F22-9B86-A0B070484ACF.png&#34; alt=&#34;FBC00415-D1AE-4F22-9B86-A0B070484ACF&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;遇到的小问题&#34;&gt;遇到的小问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;K近邻算法的model没有model.recommend_all方法。&lt;/li&gt;
&lt;li&gt;model.recommend与model.recommend_all的返回数据结构不同，model.recommend是包含评分的，而model.recommend_all只返回ID。&lt;/li&gt;
&lt;li&gt;recommend(0)，传入第一个用户ID，与recommend_all[0]，取出第一个用户ID，两者的结果是不一样的，不管用什么算法都一样！去年12月就有这样的issue：https://github.com/benfred/implicit/issues/299，我解决了，回复了这个issue。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;猜想，因为recommend方法用到indices的原因？试着重新构建下user-item维度的sparse matrix。改完后，果然就一致了。技术原因，sparse matrix transpose后，indices是未转置前的indices，没有变化。 具体地，user_items.indices与item_users.T.indices是不同的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/159B8A3D-4238-401B-A4D3-61E086FF9F0B.png&#34; alt=&#34;159B8A3D-4238-401B-A4D3-61E086FF9F0B&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;ALS算法在Mac上表现稀烂啊，同样的代码。ALS_Faiss还报错了。先在Linux上用吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mac上的ALS效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/409E288C-81F6-4588-8731-9849D1F3278B.png&#34; alt=&#34;409E288C-81F6-4588-8731-9849D1F3278B&#34;&gt;&lt;/p&gt;
&lt;p&gt;Linux上的ALS效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/8DD26395-F62D-4DA8-A801-493098799456.png&#34; alt=&#34;8DD26395-F62D-4DA8-A801-493098799456&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;冷启动&#34;&gt;冷启动&lt;/h2&gt;
&lt;p&gt;一开始并没有那么多行为数据。训练出的结果肯定是挺一般的。这时候用标签推荐，运营根据经验配置标签和推荐的映射即可。&lt;/p&gt;
&lt;h2 id=&#34;考虑用户特征商品特征而不仅仅是id&#34;&gt;考虑用户特征、商品特征（而不仅仅是ID）&lt;/h2&gt;
&lt;p&gt;如果有user特征、item特征，可以使用更一般的监督学习算法。或是使用factorization machine。&lt;/p&gt;
- https://xujiahua.github.io/posts/20200211-recsys-implicit/ - </description>
        </item>
    
    
    
        <item>
        <title>2019 eBay Big Data TechDay</title>
        <link>https://xujiahua.github.io/posts/20191123-ebay-bigdata-techday/</link>
        <pubDate>Sat, 23 Nov 2019 16:13:01 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20191123-ebay-bigdata-techday/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20191123-ebay-bigdata-techday/ -&lt;p&gt;（笔记迁移 @ 2020年）&lt;/p&gt;
&lt;p&gt;现场听了下eBay大数据的分享。视频/PPT &lt;a href=&#34;https://www.slidestalk.com/ebay&#34;&gt;https://www.slidestalk.com/ebay&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总体感觉，很棒。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;环境很好。德国中心，提供了星巴克、点心。&lt;/li&gt;
&lt;li&gt;技术氛围好。几百人做大数据呢！而且做得都比较深。&lt;/li&gt;
&lt;li&gt;拥抱开源：基于开源的二次开发，外围开发，平台化（易用性）等工作。&lt;/li&gt;
&lt;li&gt;风控经理演讲水平好棒。&lt;/li&gt;
&lt;li&gt;Spark SQL / Flink Streaming / Spark Streaming / ElasticSearch 这些是目前大数据的主流&lt;/li&gt;
&lt;li&gt;真正投身大数据，最优选择是学习Spark。&lt;/li&gt;
&lt;li&gt;没有中奖，不过拿了小礼物，心里美滋滋。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;应用角度data-driven-payment-risk&#34;&gt;【应用角度】Data Driven Payment Risk&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;演讲、台风挺好的。&lt;/li&gt;
&lt;li&gt;内容方面没有很新颖但是很扎实（基于图算法的挖掘其实挺少听见的，是让人眼前一亮的东西，但是我之前正好看过这块了。）。&lt;/li&gt;
&lt;li&gt;基本上是在支付风控这个应用角度。&lt;/li&gt;
&lt;li&gt;如果去PayPal，这块支付风控是可以好好学习的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;flink-streamingrheos-sql-a-real-time-processing-language&#34;&gt;【Flink Streaming】Rheos-SQL: A Real-Time Processing Language&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;两个年轻人联合做的分享。&lt;/li&gt;
&lt;li&gt;基于Flink的，Flink还有SQL功能。Flink这块我没接触。&lt;/li&gt;
&lt;li&gt;扩展SQL语法的思路，加入了一些新功能，比如sqlflow也是这么做的（阿里巴巴）。写SQL就能连Kafka、ES。这点很不错的扩展。&lt;/li&gt;
&lt;li&gt;还做了一个平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;spark-streamingdesigning-etl-pipelines-with-structured-streaming-and-delta-lake&#34;&gt;【Spark Streaming】Designing ETL pipelines with Structured Streaming and Delta lake&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;干货不多，一些最佳实践（因为没怎么做过streaming，印象不深）。感觉是Delta Lake的推广。&lt;/li&gt;
&lt;li&gt;Delta Lake能替换hive么？&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;elasticsearchpronto---elasticsearch-as-a-service-at-ebay&#34;&gt;【ElasticSearch】Pronto - ElasticSearch as a service at ebay&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Kibaba插件开发扩展ELK&lt;/li&gt;
&lt;li&gt;做了一个平台管理ES。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;aibigdatanous---empower-data-analysis-through-augmented-analytics&#34;&gt;【AI+BigData】Nous - Empower Data Analysis through Augmented Analytics&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;增强分析。大数据分析+知识图谱，自然语言处理（英文）。这个topic太时髦了。&lt;/li&gt;
&lt;li&gt;演示效果，界面真很好看了。&lt;/li&gt;
&lt;li&gt;风趣的开场白。技术又好。&lt;/li&gt;
&lt;li&gt;英语对话，这么流利。有被刺激到。&lt;/li&gt;
&lt;li&gt;从规则引擎开始&lt;/li&gt;
&lt;li&gt;积累数据，机器学习生成规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;spark-sqlcarmel---optimizing-sparksql-for-interative-analysis&#34;&gt;【Spark SQL】Carmel - Optimizing SparkSQL for Interative Analysis&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;eBay优化Spark sql（改写内部代码）替换TeraData，作为MPP方案。Impala不好吗。。。&lt;/li&gt;
&lt;li&gt;观众提问，SQL on spark没有索引，是不是历史的倒退。有个问题挺好。回答是下推到parquet，列式存储会过滤。&lt;/li&gt;
&lt;li&gt;是大牛，技术做的很深。Druid/Kylin/Spark/Spark SQL。一句话很经典，批处理也可以很快。&lt;/li&gt;
&lt;li&gt;演讲基本上是站着不动，看着PPT疯狂输出信息。&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/20191123-ebay-bigdata-techday/ - </description>
        </item>
    
    
    
        <item>
        <title>量子计算——读「古今密码学趣谈」展望未来的密码学</title>
        <link>https://xujiahua.github.io/posts/20191031-quantum-computer/</link>
        <pubDate>Thu, 31 Oct 2019 15:22:33 +0800</pubDate>
        
        <guid>https://xujiahua.github.io/posts/20191031-quantum-computer/</guid>
        <description>许嘉华的笔记 https://xujiahua.github.io/posts/20191031-quantum-computer/ -&lt;p&gt;（笔记迁移 @ 2020年）&lt;/p&gt;
&lt;p&gt;主要讲了密码学怎么来应对量子计算。量子计算的并行性（N个量子位，能&lt;strong&gt;同时&lt;/strong&gt;表示2^N个数字，而同样的比特位，同时只能表示一个2^N以内的数字。太神奇了），将以前指数级别的破解难度降低为了线性级别。RSA、ECC等现代密码学技术都会被轻易攻破。&lt;/p&gt;
&lt;p&gt;量子计算机的历史：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在美国电话电报公司贝尔实验室工作的数学家肖尔（Peter W.Shor，1959）于1994年发现了快速分解大整数的量子算法！他因此于1998年获得了由国际数学联盟颁发的奈望林纳应用数学奖。&lt;/li&gt;
&lt;li&gt;2001年，美国IBM公司率先研制成功7个量子位的示例型量子计算机。&lt;/li&gt;
&lt;li&gt;2007年2月，加拿大D-Wave System公司宣布研制成功世界上第一台商用16量子位的量子计算机。&lt;/li&gt;
&lt;li&gt;2011年5月30日，D-Wave System公司宣布研制成功128量子位的量子计算机，并且出人意料地以每台 1000万美元的价格公开出售，还提供与传统计算机软件接口的软件工具包。&lt;/li&gt;
&lt;li&gt;2011年9月2日，美国加州大学圣芭芭拉分校的科学家宣布，已通过量子电路成功实现了冯·诺依曼计算机结构，证实了未来量子大规模集成电路指日可待。&lt;/li&gt;
&lt;li&gt;2012 年3月1日，美国IBM公司宣布，找到一种可以提升量子计算机规模的关键技术，从而使大规模量子计算机的实现成为可能&lt;/li&gt;
&lt;li&gt;In 2015, D-Wave&amp;rsquo;s 2X Quantum Computer with more than &lt;strong&gt;1000 qubits&lt;/strong&gt; was installed at the Quantum Artificial Intelligence Lab at NASA Ames Research Center.&lt;/li&gt;
&lt;li&gt;January 2017 &lt;strong&gt;2048 qubits&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;In 2019, D-Wave announced a &lt;strong&gt;5000 qubit&lt;/strong&gt; system available &lt;strong&gt;mid-2020&lt;/strong&gt;, using their new Pegasus chip with 15 connections per qubit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于Dwave，客观看待，以下是引用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-20191031151535708.png&#34; alt=&#34;image-20191031151535708&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Dwave的量子退火提速找机器学习中的最优解，这是个很实用的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;量子计算机中的算法需要特殊设计的。&lt;/p&gt;
&lt;p&gt;现代密码学是基于一些数学难题的，比如大整数分解、椭圆曲线。为了对抗量子计算破解，如果继续走基于数学路线，就需要找新的数学难题，比如基于格的难题（虽然接触过，但还是无法理解）。&lt;/p&gt;
&lt;p&gt;非数学难题思路的应对方式（看的一知半解）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;量子密码。思路起源：1969 年，美国哥伦比亚大学的一位名叫威斯纳（Stephen Wiesner，1942）的研究生完成了一篇题为“共轭编码”（Conjugate Coding）的论文，其中提出了“量子钱”（Quantum Money）的概念。根据量子力学原理，任何对量子的观察必然都会干扰其原来的状态，从而导致钱币失效。| 所以，使用量子密码达到安全通信的根本就是一旦观察会干扰其原来的状态。（现代密码学是对通信内容进行加密。）&lt;/li&gt;
&lt;li&gt;生物密码，指的是DNA密码，DNA的形成是一个分子生物过程。一条DNA链由数百万个的基本单位按不同的顺序排列而成，所以其中包含了惊人的信息量。从数学的角度来看，一条DNA链是由4种不同的符号A,G,C,T组成的长串，类似于计算机所处理的以0,1组成的符号串。但DNA的形成是一个分子生物过程，并非数学计算的结果。于是科学家们突发奇想：能否利用形成DNA的分子生物过程来解决数学问题呢？| 将信息隐藏在DNA微点（微点的定义？）&lt;/li&gt;
&lt;li&gt;混沌密码。实践更少了。不做赘述。混沌，蝴蝶效应源于此。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;D-Wave Systems &lt;a href=&#34;https://en.wikipedia.org/wiki/D-Wave_Systems&#34;&gt;https://en.wikipedia.org/wiki/D-Wave_Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何用 IT 业者能听懂的话介绍量子计算的原理？ &lt;a href=&#34;https://www.zhihu.com/question/26933442/answer/34598726&#34;&gt;https://www.zhihu.com/question/26933442/answer/34598726&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://xujiahua.github.io/posts/20191031-quantum-computer/ - </description>
        </item>
    
    
  </channel>
</rss> 