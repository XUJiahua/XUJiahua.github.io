<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on 许嘉华的博客</title>
    <link>https://xujiahua.github.io/tags/docker/</link>
    <description>Recent content in Docker on 许嘉华的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 03 Apr 2020 15:43:07 +0800</lastBuildDate>
    
	<atom:link href="https://xujiahua.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker日志驱动小结</title>
      <link>https://xujiahua.github.io/posts/docker-logging/</link>
      <pubDate>Fri, 03 Apr 2020 15:43:07 +0800</pubDate>
      
      <guid>https://xujiahua.github.io/posts/docker-logging/</guid>
      <description>docker logs， kubectl logs能看到Docker容器的标准输出、标准错误，方便定位问题。而 xxx logs之所以能看到，是因为标准输出、标准错误存储在每个容器独有的日志文件中。
另外日志量大了，用docker logs看历史数据不大合适。我们就需要考虑将日志存储到日志中心去。
Docker默认支持如下日志驱动。有直接写文件的，有使用云服务的。下面简单介绍下。
credit: https://jaxenter.com/docker-logging-gotchas-137049.html
官方文档 https://docs.docker.com/config/containers/logging/configure/
默认驱动：json-file 默认的Logging Driver是json-file。docker info可以查看。全局的日志驱动设置，可以修改daemon配置文件 /etc/docker/daemon.json。
写入文件的日志格式长这样：{&amp;quot;log&amp;quot;:&amp;quot;Log line is here\n&amp;quot;,&amp;quot;stream&amp;quot;:&amp;quot;stdout&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2019-01-01T11:11:11.111111111Z&amp;quot;}，每一行是一个json文件，log字段为容器原来输出的每行内容。
默认配置，创建的容器的信息在这个目录下： /var/lib/docker/containers。
实验 root@ubuntu-parallel:~# docker run --name default_logging_driver hello-world root@ubuntu-parallel:~# cd /var/lib/docker/containers/$(docker ps --no-trunc -aqf &amp;#34;name=default_logging_driver&amp;#34;) root@ubuntu-parallel:~# cat $(docker ps --no-trunc -aqf &amp;#34;name=default_logging_driver&amp;#34;)-json.log {&amp;#34;log&amp;#34;:&amp;#34;\n&amp;#34;,&amp;#34;stream&amp;#34;:&amp;#34;stdout&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2020-04-02T01:46:54.096347888Z&amp;#34;} {&amp;#34;log&amp;#34;:&amp;#34;Hello from Docker!\n&amp;#34;,&amp;#34;stream&amp;#34;:&amp;#34;stdout&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2020-04-02T01:46:54.096377382Z&amp;#34;} {&amp;#34;log&amp;#34;:&amp;#34;This message shows that your installation appears to be working correctly.\n&amp;#34;,&amp;#34;stream&amp;#34;:&amp;#34;stdout&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2020-04-02T01:46:54.096381118Z&amp;#34;} {&amp;#34;log&amp;#34;:&amp;#34;\n&amp;#34;,&amp;#34;stream&amp;#34;:&amp;#34;stdout&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2020-04-02T01:46:54.096383725Z&amp;#34;} https://docs.docker.com/config/containers/logging/json-file/
怎么记录更多上下文信息 未有定论，TODO。
翻看文档，能够记录的上下文信息非常有限，基本上是没有。有限的上下文信息包括容器ID，因为日志文件名包含了容器ID。但是容器ID也就够区分哪些日志是在一个进程实例，仅此而已。不知道进程到底是哪个服务。
如果能记录下镜像名称就好很多。
其他驱动可以记录一些上下文信息，https://docs.docker.com/config/containers/logging/log_tags/，倒是json-file不支持。issue https://github.com/moby/moby/issues/19803
看起来，使用docker logs和 收集容器名称、镜像名称等上下文数据，无法兼顾。</description>
    </item>
    
    <item>
      <title>使用 Docker Machine</title>
      <link>https://xujiahua.github.io/posts/use-docker-machine/</link>
      <pubDate>Tue, 31 Mar 2020 09:53:05 +0800</pubDate>
      
      <guid>https://xujiahua.github.io/posts/use-docker-machine/</guid>
      <description>简介 Docker Machine lets you create Docker hosts on your computer, on cloud providers, and inside your own data center. It creates servers, installs Docker on them, then configures the Docker client to talk to them.
参考：
 https://github.com/docker/machine https://docs.docker.com/machine/overview/  vs. Vagrant 与Vagrant的交集 目前使用 Vagrant 搭 Docker 环境的步骤如下：
 vagrant init {box_name}，下载一个基础的虚拟机镜像，比如centos，并创建一个Vagrantfile。 Vagrantfile中设置虚拟机hostname。 Vagrantfile中设置Private network，使得几个VM可以互相通信。 VM内安装docker软件。  如果用上了docker-machine，只要一行命令。在这个场景上，docker-machine 比 Vagrant 方便了很多。
docker-machine create -d virtualbox {host_name} VM的管理，vagrant命令需要在Vagrantfile所在目录执行。而docker-machine可以在任何目录管理VM。
其他特色  通过其他driver，可以安装管理云主机或是私有数据中心，而不仅仅是virtualbox。 通过eval &amp;ldquo;$(docker-machine env default)&amp;quot;，覆盖环境变量DOCKER_HOST，使得本地docker client访问VM内的docker daemon。 更多实用命令，参考 https://docs.</description>
    </item>
    
    <item>
      <title>Docker Network小结</title>
      <link>https://xujiahua.github.io/posts/docker-network/</link>
      <pubDate>Sat, 21 Mar 2020 14:10:40 +0800</pubDate>
      
      <guid>https://xujiahua.github.io/posts/docker-network/</guid>
      <description>Docker网络非常值得学习。对Docker不熟的同学，建议先看一些入门资料。
Docker 学习资料  Docker — 从入门到实践 https://www.yuque.com/grasilife/docker Docker Kubernetes Lab Handbook https://docker-k8s-lab.readthedocs.io/en/latest/index.html 「Docker进阶与实战」华为Docker实践小组  单机网络 （建议在Linux系统上实验。）
Docker安装完后，默认有三个（三种）网络。分别是默认的bridge模式，host模式，none模式。
# docker network ls NETWORK ID NAME DRIVER SCOPE 51cbe7a9bb19 bridge bridge local 7182ef9fa8c4 host host local bd80d0dedaa8 none null local 参考：https://docs.docker.com/network/
none模式 &amp;ndash;net=none 无网络。
# docker run --net=none --rm -it alpine ip addr show 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever host模式 &amp;ndash;net=host  容器共用宿主机的网络。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 容器不会申请独立的IP。 容器申请的端口占用宿主机的端口资源。 -p等端口映射命令不起作用：WARNING: Published ports are discarded when using host network mode 性能上比较好，因为没有地址转换。Host mode networking can be useful to optimize performance, and in situations where a container needs to handle a large range of ports, as it does not require network address translation (NAT), and no “userland-proxy” is created for each port.</description>
    </item>
    
  </channel>
</rss>