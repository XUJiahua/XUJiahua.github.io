<!DOCTYPE html>
<html lang="zh-cn">
    <head>
	<meta name="generator" content="Hugo 0.67.1" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>许嘉华的博客</title>
        <meta name="Description" content=""><meta property="og:title" content="许嘉华的博客" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xujiahua.github.io/" />
<meta property="og:updated_time" content="2020-04-02T16:58:23+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="许嘉华的博客"/>
<meta name="twitter:description" content=""/>
<meta name="theme-color" content="#ffffff">
<meta name="msapplication-TileColor" content="#da532c">
<link rel="canonical" href="https://xujiahua.github.io/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="alternate" href="/index.xml" type="application/rss+xml" title="许嘉华的博客">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="许嘉华的博客"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.9a680b90260b5106d79f4075491ab31daafa7429eff686453c40b58357309649.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="><link rel="stylesheet" href="/lib/animate/animate.min.3c770e90f98eb21b0c042fafb49755af93306fbaf42e449524f94fae9fc83295.css" integrity="sha256-PHcOkPmOshsMBC&#43;vtJdVr5Mwb7r0LkSVJPlPrp/IMpU="><link rel="stylesheet" href="/css/style.min.e8ca640cf5b1714eaa34bc21e8e2d0e79ae9cc05a934f6ee78a318487d7c515b.css" integrity="sha256-6MpkDPWxcU6qNLwh6OLQ55rpzAWpNPbueKMYSH18UVs=">
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "\/","name": "许嘉华的博客"
    }
    </script></head>
    <body><script>
            if (!window.localStorage || !window.localStorage.getItem('theme')) {window.isDark = '' === 'dark';} else {
                window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            }
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title animated bounceIn">
            <a href="/">许嘉华的博客</a>
        </div>
        <div class="menu"><a class="menu-item" href="/posts/">Posts</a><a class="menu-item" href="/tags/">Tags</a><a class="menu-item" href="/categories/">Categories</a><a class="menu-item" href="/about/">About</a><a href="javascript:void(0);" class="theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-rotate-180 fa-fw"></i>
            </a>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-wrapper">
        <div class="header-container">
            <div class="header-title animated bounceIn">
                <a href="/">许嘉华的博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a href="javascript:void(0);" class="theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-rotate-180 fa-fw"></i>
            </a>
        </div>
    </div>
</header>

<script>
    window.desktopHeaderMode =  null ;
    window.mobileHeaderMode =  null ;
</script>
<main class="main">
                <div class="container"><div class="page home"><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/use-fluentd/">Fluentd实战</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-04-02>2020-04-02</time>
        </span></div><div class="content">以收集Docker容器日志的例子，介绍下Fluentd的用法。
安装 Fluentd Ubuntu 18.04上的安装命令（https://docs.fluentd.org/installation/install-by-deb）：
root@ubuntu-parallel:~# curl -L https://toolbelt.treasuredata.com/sh/install-ubuntu-bionic-td-agent3.sh | sh 以Daemon方式启动：
root@ubuntu-parallel:~# systemctl start td-agent.service root@ubuntu-parallel:~# systemctl status td-agent.service fluentd的安装目录是在/opt/td-agent/下的。为演示方便，我们可以直接使用 /opt/td-agent/embedded/bin/fluentd这个程序。
root@ubuntu-parallel:~# ps -ef | grep fluentd td-agent 30596 1 0 17:10 ? 00:00:00 /opt/td-agent/embedded/bin/ruby /opt/td-agent/embedded/bin/fluentd --log /var/log/td-agent/td-agent.log --daemon /var/run/td-agent/td-agent.pid td-agent 30602 30596 9 17:10 ? 00:00:00 /opt/td-agent/embedded/bin/ruby -Eascii-8bit:ascii-8bit /opt/td-agent/embedded/bin/fluentd --log /var/log/td-agent/td-agent.log --daemon /var/run/td-agent/td-agent.pid --under-supervisor 其他系统的安装参考：https://docs.fluentd.org/installation
小试牛刀 配置文件 test.conf，启动一个HTTP服务，并把接收到的日志，打印到标准输出。
&lt;source&gt; @type http port 9880 &lt;/source&gt; &lt;match *.*&gt; @type stdout &lt;/match&gt; 启动fluentd进程。</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/use-fluentd/">Read More</a></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/use-docker-machine/">使用 Docker Machine</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-31>2020-03-31</time>
        </span></div><div class="content">简介 Docker Machine lets you create Docker hosts on your computer, on cloud providers, and inside your own data center. It creates servers, installs Docker on them, then configures the Docker client to talk to them.
参考：
 https://github.com/docker/machine https://docs.docker.com/machine/overview/  vs. Vagrant 与Vagrant的交集 目前使用 Vagrant 搭 Docker 环境的步骤如下：
 vagrant init {box_name}，下载一个基础的虚拟机镜像，比如centos，并创建一个Vagrantfile。 Vagrantfile中设置虚拟机hostname。 Vagrantfile中设置Private network，使得几个VM可以互相通信。 VM内安装docker软件。  如果用上了docker-machine，只要一行命令。在这个场景上，docker-machine 比 Vagrant 方便了很多。
docker-machine create -d virtualbox {host_name} VM的管理，vagrant命令需要在Vagrantfile所在目录执行。而docker-machine可以在任何目录管理VM。
其他特色  通过其他driver，可以安装管理云主机或是私有数据中心，而不仅仅是virtualbox。 通过eval &ldquo;$(docker-machine env default)&quot;，覆盖环境变量DOCKER_HOST，使得本地docker client访问VM内的docker daemon。 更多实用命令，参考 https://docs.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/use-docker-machine/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/docker">
                            <i class="fas fa-tag fa-fw"></i>Docker
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/use-consul/">Consul调研</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-26>2020-03-26</time>
        </span></div><div class="content">Consul简介 Consul 是 HashiCorp 公司推出的开源分布式服务发现与配置系统。
 服务发现。特别是搭配Consul Connect（Service Mesh），可达到一种无侵入式的服务发现和客户端负载均衡。 Key/Value 存储 作为配置中心。 使用 Raft 算法来保证一致性。 支持多数据中心。 支持健康检查：服务注册的时候可以提供健康检查项，服务发现会过滤掉不健康的service。 支持 http 和 dns 协议接口。 Web 管理界面。 没有长连接，轮询方式可能不够及时。  核心概念  consul agent server：维护核心状态并参与leader选举。server节点一般建议3个或是5个，测试用1个即可。写压力大的集群，考虑升级服务器实例的配置和低延迟的存储。（TIP For write-heavy clusters, consider scaling vertically with larger machine instances and lower latency storage. https://learn.hashicorp.com/consul/datacenter-deploy/reference-architecture） consul agent client：与其他agent联通，并消息中转。每个主机都有一个agent的好处是，只要与本地agent通信，不用设置CONSUL_HTTP_ADDR，代码也不用指定这个地址。方便无脑操作。(In a multi-agent Consul datacenter, each service would register with its local Consul client, and the clients would forward the registration to the Consul servers, which maintain the service catalog.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/use-consul/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/service-mesh">
                            <i class="fas fa-tag fa-fw"></i>Service Mesh
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/consul">
                            <i class="fas fa-tag fa-fw"></i>consul
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/docker-network/">Docker Network小结</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-21>2020-03-21</time>
        </span></div><div class="content">Docker网络非常值得学习。对Docker不熟的同学，建议先看一些入门资料。
Docker 学习资料  Docker — 从入门到实践 https://www.yuque.com/grasilife/docker Docker Kubernetes Lab Handbook https://docker-k8s-lab.readthedocs.io/en/latest/index.html 「Docker进阶与实战」华为Docker实践小组  单机网络 （建议在Linux系统上实验。）
Docker安装完后，默认有三个（三种）网络。分别是默认的bridge模式，host模式，none模式。
# docker network ls NETWORK ID NAME DRIVER SCOPE 51cbe7a9bb19 bridge bridge local 7182ef9fa8c4 host host local bd80d0dedaa8 none null local 参考：https://docs.docker.com/network/
none模式 &ndash;net=none 无网络。
# docker run --net=none --rm -it alpine ip addr show 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever host模式 &ndash;net=host  容器共用宿主机的网络。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 容器不会申请独立的IP。 容器申请的端口占用宿主机的端口资源。 -p等端口映射命令不起作用：WARNING: Published ports are discarded when using host network mode 性能上比较好，因为没有地址转换。Host mode networking can be useful to optimize performance, and in situations where a container needs to handle a large range of ports, as it does not require network address translation (NAT), and no “userland-proxy” is created for each port.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/docker-network/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/docker">
                            <i class="fas fa-tag fa-fw"></i>Docker
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/network">
                            <i class="fas fa-tag fa-fw"></i>network
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/go-web-project/">Go Web 项目框架</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-20>2020-03-20</time>
        </span></div><div class="content">常用开源库 依赖包管理 Go Modules Go Modules。Go 从1.11版本开始支持，Go 1.14被认为是生产可用了。个人用过最方便的Go依赖包管理工具了。
版本管理中维护 go.mod/go.sum 两个文件。
参考  Using Go Modules https://blog.golang.org/using-go-modules  命令行框架 Corba Corba。第一次看到，是在翻看 Hyperledger Fabric 的时候。
 子命令，嵌套的子命令。 增强版本的flags。 项目模板的生成工具。 生成工具也自动引入了Viper这个包。Corba与Viper由一个作者开发，两个项目配合使用非常方便。  建议使用Cobra命令行工具生成项目模板。
 ▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go 参考  A Commander for modern Go CLI interactions https://github.com/spf13/cobra Cobra Generator https://github.com/spf13/cobra/blob/master/cobra/README.md  配置管理 Viper Viper。常常与Corba搭配使用。抄一段官方简介：
Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/go-web-project/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/golang">
                            <i class="fas fa-tag fa-fw"></i>Golang
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/web">
                            <i class="fas fa-tag fa-fw"></i>Web
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/slash-in-url-path/">Go库对URL Path中%2F的处理</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-12>2020-03-12</time>
        </span></div><div class="content">问题描述  有同事反馈Go项目的接口404了。看了下nginx日志，只有部分请求404了，404请求的显著特征是URL里有%2F，也就是/的转义。 接口定义是这样的：/api/xxx/{mid}/{uid}。mid、uid是URL path的一部分。从现象来看，程序没处理好转义字符，因为多了一个path部分，路由不匹配了，404。 nginx的URL记录是%2F，其实调用方传的是微信ID，比如IEd5W/jqsdF9qpuagQscEg==。调用方在发请求之前对ID已经做好了转义。  Go内置库：不区分%2F和/ An application cannot distinguish between &ldquo;/&rdquo; used as a path segment delimiter and &ldquo;/&rdquo; encoded in a path segment.
这个问题由来已久了，看着官方也不打算解决了，见这个issue：https://github.com/golang/go/issues/3659
If your app needs to assign special meaning, the server can reprocess req.RequestURI as it sees fit, and the client can issue requests using &amp;url.URL{Opaque: rawURI}.  reprocess req.RequestURI 就是让你别用内置路由库了。 issue requests using &amp;url.URL{Opaque: rawURI}. 试了，问题没解决。客户端不管怎么做，最终都是以HTTP协议输出的。GET http://www.google.com/index.html HTTP/1.1 服务端代码最终解析的还是中间的那段URL文本。照理就不通啊。  源码角度 url.URL的定义，明确指出Path字段存储的是decode之后的数据，所以%2F在这里已经被转义成了/，跟之前的Path意义完全不同了。</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/slash-in-url-path/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/go">
                            <i class="fas fa-tag fa-fw"></i>Go
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/go-router">
                            <i class="fas fa-tag fa-fw"></i>Go router
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/bug">
                            <i class="fas fa-tag fa-fw"></i>Bug
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/patent/">专利申请流程小结</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-11>2020-03-11</time>
        </span></div><div class="content">去年憋的一篇专利，到申请公布阶段了，算是去年研究区块链的副成果。https://patents.google.com/patent/CN110807211。整理下专利申请流程。
专利申请流程 主要流程如下图，来自网络。
技术成果生成 有可以申请专利的点，这个因人而异。基于点子，写个草稿。
申请专利 找一个专利代理，让他们提供专利稿的修改意见。反复迭代直到专利代理觉得没问题了。
之后专利代理会出具一份「专利申请受理通知书」，你再交点钱，可能还会有税费减免。
我遇到了专利代理看不大懂专利的情况，僵持了一段时间，后面换了一家顺畅好多。
专利申请公布 这个时间点叫做：申请公布日。
说明初审过了。实用新型和外观发明的话，直接就授权了，而发明还需要实质审查。
&ldquo;初步审查合格后，实用新型和外观就直接授权了，而发明还要经过实质审查，检索国内外的资料，确认没有相同的才会授权，所以发明的含金量会高很多，因此发明专利审查的时间也会是比较长的，一般从申请到拿证书都需要2-3年，而实用、外观这两项专利一年能拿到。&rdquo;
专利授权公告 这个时间点叫做：授权公告日。
说明正式审查完了。这时候才算是真正拥有专利。</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/patent/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/%E4%B8%93%E5%88%A9">
                            <i class="fas fa-tag fa-fw"></i>专利
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/github-pages-restart/">Github pages重新开始：使用Hugo、Typora</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-10>2020-03-10</time>
        </span></div><div class="content">重新开始GitHub pages 曾使用GitHub pages +  jekyll 写过一段时间博客，没啥营养。
打算重新开始：
 把我记录在Evernote和Typora中的资料迁移到GitHub pages上。 另外做一些Web形式的小工具，挂载在一个子目录里，方便平时使用。  Hugo + Typora 打算如下：
 Markdown文件还是使用Typora写。用过MWeb、Typora，Typora使用感受更好些（这么好用还不要钱）。 Hugo作为静态网站生成，创建一个博客模板。  Hugo quickstart # 安装hugo（其实是Go编译的二进制文件） brew install hugo # 创建site hugo new site quickstart # 通过git submodule的方式下载主题 git init git submodule -b master add https://github.com/dillonzq/LoveIt themes/LoveIt # 更新config.toml，配置主题参数，见loveit配置 # 创建博客，创建的posts在content目录下。文件格式为：content/&lt;CATEGORY&gt;/&lt;FILE&gt;.&lt;FORMAT&gt; # hugo new 会采用 archetypes/default.md作为模板，把一些共性配置放在这个模板里吧。 hugo new posts/my-first-post.md # 本地看blog效果，-D表示草稿状态的博客也显示 hugo server -D # 生成静态网站到./public/，也可以指定目录 hugo -D 挑选了一个比较实用的主题 https://hugoloveit.com/</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/github-pages-restart/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/github-pages">
                            <i class="fas fa-tag fa-fw"></i>GitHub pages
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/hugo">
                            <i class="fas fa-tag fa-fw"></i>Hugo
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/typora">
                            <i class="fas fa-tag fa-fw"></i>Typora
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/use-hyper-v/">Hyper-V使用体验</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-03-03>2020-03-03</time>
        </span></div><div class="content">Hyper-V 使用体验 Hyper-V是 Windows10 内置的虚拟机软件，没想到我会用到它。
为什么要用Hyper-V  需要使用虚拟机来模拟Kubernetes环境。 Windows Docker依赖Hyper-V。貌似WSL2也是基于Hyper-V。应该是不会卸载Hyper-V了。 Hyper-V与其他虚拟机软件（VirtualBox, VMWare）冲突，用不了其他的，只能用Hyper-V。 Hyper-V与VirtualBox兼容的方案有没有。可能有，不想过于折腾了，那就不得不用。  Hyper-V好不好用  使用体验太差了，从Mac、从其他虚拟机使用过来，默认配置各种踩坑。 安装VM碰到DHCP超时的问题，反复试验无果，重启Windows后VM的DHCP不超时了。总结下，Windows上，如果怎么搞都搞不定，重启下可能就好了。WTF！ 自带的NAT网络有点残疾，VM配置静态IP，网络就不通了。不像VirtualBox是开箱即用的。 最后借助网络上的零碎信息自定义了下NAT网络，各种神奇配置。 Windows还是很屎，除了打游戏，开发体验跟我之前的体验一样糟。最后搞定花了我一天时间。要是用VMware/VirtualBox，可能在2个小时内就能搞定。总结，不好用。  Hyper-V 创建和克隆VM 创建VM 从*.iso文件创建VM。
 注意，Linux VM，不启用Windows Secure Boot。 更多选项里，设置VM的名称和交换机。 体验不好的地方：左上方的「选择操作系统」区域有长时间的加载过程，即使使用本地镜像文件也得等。  克隆VM 从硬盘文件创建VM。
 克隆是为了减少重复配置一些基础环境的工作量。 不像VirtualBox那样有直观的克隆按钮。摸索出的克隆功能是这样的：就是从VM硬盘创建VM。 建议先关机母体VM后，再基于母体VM的硬盘文件克隆。防止母体VM开机状态下一些更新并没有持久化到硬盘文件中。  Hyper-V NAT网络搭建总结 如果使用VMWare/VirtualBox的话，NAT网络是完全自动搭建的。
VMWare中有三种网络模式，Bridging、NAT、Host-only分别对应Hyper-V下的三种交换机，外部、内部、专用。
 Bridging：VM使用物理网络。GUEST VM与HOST相当于通过交换机连上一个网络（细节不确定）。 NAT：VM使用虚拟网络，HOST同时连入物理网络和虚拟网络。VM出口流量都会通过HOST，使用HOST IP。 Host-only：在NAT基础上，VM连不上外网，除非有路由设置。  默认的NAT网络 默认交换机支持NAT，但是瑕疵不少，无法满足工作需要。
Hyper-V Default Switch + VM DHCP 的组合默认有了NAT功能，满足以下：
 虚拟机之间可以互相访问 虚拟机与物理机之间可以互相访问 虚拟机可以访问互联网  但是：
 每次重启，Default Switch的IP都会变，Windows10 物理机上的网卡IPv4配置无法让他不变。 ping baidu.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/use-hyper-v/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/hyper-v">
                            <i class="fas fa-tag fa-fw"></i>Hyper-V
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/vm">
                            <i class="fas fa-tag fa-fw"></i>VM
                        </a>
                    </span></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="https://xujiahua.github.io/posts/go-modules/">使用Go Modules</a>
    </h1><div class="post-meta"><span class="post-author">
            <a class="author" href="/" rel="author" target="_blank">
                <i class="fas fa-user-circle fa-fw"></i>Author
            </a>
        </span>&nbsp;<span class="post-publish">
            published on&nbsp;<time datetime=2020-02-28>2020-02-28</time>
        </span></div><div class="content">Go Modules使用着感觉不错，Go终于有正常点的依赖管理工具了。记录一二。
使用小结  go.mod, go.sum加入版本管理 Both go.mod and go.sum should be checked into version control. 直接依赖体现在go.mod，间接依赖由直接依赖自己管理，这是个递归的过程 Only direct dependencies are recorded in the go.mod file. go命令自动管理go.mod，这可太方便了 When it encounters an import of a package not provided by any module in go.mod, the go command automatically looks up the module containing that package and adds it to go.mod, using the latest version. 看着比之前的依赖管理好用很多。比如dep。因为网络下载包等问题，最后把依赖包全checkin到vendor目录了。太臃肿。  常用命令  go mod init creates a new module, initializing the go.</div><div class="post-footer">
        <a href="https://xujiahua.github.io/posts/go-modules/">Read More</a><div class="post-tags">&nbsp;<span>
                        <a href="/tags/go">
                            <i class="fas fa-tag fa-fw"></i>Go
                        </a>
                    </span>&nbsp;<span>
                        <a href="/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">
                            <i class="fas fa-tag fa-fw"></i>依赖管理
                        </a>
                    </span></div></div>
</article>
<ul class="pagination"><li class="page-item active">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a>
        </div>

        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span></div>
    </div>
</footer>
</div><a href="#" class="dynamic-to-top animated faster" id="dynamic-to-top">
            <span>&nbsp;</span>
        </a><script>
        document.addEventListener('DOMContentLoaded', function () {
            lightGallery(document.getElementById('content'), {
                selector: '.lightgallery',
                speed: 400,
                hideBarsDelay: 2000,
                thumbnail: true,
                exThumbImage: 'data-thumbnail',
                thumbWidth: 80,
                thumbContHeight: 80,
            });
        });
    </script><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.a0f67639490aba5d9a250783c0aa0ed69f83a6f151fb0d7b9fb617c9dbc54565.css" integrity="sha256-oPZ2OUkKul2aJQeDwKoO1p&#43;DpvFR&#43;w17n7YXydvFRWU="><script src="/lib/smooth-scroll/smooth-scroll.polyfills.min.54590077ee163035c3dd38dc034e9f6915ecbe680dd832f449afa21672cab116.js" integrity="sha256-VFkAd&#43;4WMDXD3TjcA06faRXsvmgN2DL0Sa&#43;iFnLKsRY="></script><script src="/lib/lazysizes/lazysizes.min.876b4c12685e991d88378c1b6dd3638fd2da0c88f3c24da1ada950c1f26604e1.js" integrity="sha256-h2tMEmhemR2IN4wbbdNjj9LaDIjzwk2hralQwfJmBOE="></script><script src="/lib/lightgallery/lightgallery.min.7a84c63ab156d68e4a7269487c9c65a4eb34b0c7864f2d3fd2b87f7c664480d3.js" integrity="sha256-eoTGOrFW1o5KcmlIfJxlpOs0sMeGTy0/0rh/fGZEgNM="></script><script src="/lib/lightgallery/lg-thumbnail.min.eab31af8f90835b7ab674b2dd2474841039bc01022aa312f80dde6e22fde58d7.js" integrity="sha256-6rMa&#43;PkINberZ0st0kdIQQObwBAiqjEvgN3m4i/eWNc="></script><script src="/lib/lightgallery/lg-zoom.min.e3a7e6bb4a69f8627654ba9e0ab1252971bcfb400538dbb0605db9a3342ce5b9.js" integrity="sha256-46fmu0pp&#43;GJ2VLqeCrElKXG8&#43;0AFONuwYF25ozQs5bk="></script><script src="/js/theme.min.1482fc67bfa2c3b8cebe476d0037b9321b5b7a8a1525b547b94143948be90e9e.js" integrity="sha256-FIL8Z7&#43;iw7jOvkdtADe5MhtbeooVJbVHuUFDlIvpDp4="></script></body>
</html>
